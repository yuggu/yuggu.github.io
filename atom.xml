<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yuggu</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yuggu.github.io/"/>
  <updated>2019-11-20T05:48:14.924Z</updated>
  <id>https://yuggu.github.io/</id>
  
  <author>
    <name>yuggu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大三上计算机网络实验</title>
    <link href="https://yuggu.github.io/2019/11/20/%E5%A4%A7%E4%B8%89%E4%B8%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C/"/>
    <id>https://yuggu.github.io/2019/11/20/大三上计算机网络实验/</id>
    <published>2019-11-20T05:41:24.000Z</published>
    <updated>2019-11-20T05:48:14.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机网络实验">计算机网络实验</h2><p>  这里主要记录实验中遇到的问题与困惑； ### 第一次实验课19.11.19</p><p>  首先，什么是vlan，vlan即是Virtual Local Area Network，即虚拟局域网，对于处于相同网段的主机来说，它们的ip与对应子网掩码的结果一定相同，而对于处于相同vlan中的不同主机呢；这就涉及到vlan的划分，这里先给出几种划分方法，便于理解vlan；</p><ol type="1"><li>根据端口划分vlan，基于端口的vlan是划分vlan最简单也是最有效的方法，这实际上是某些交换端口的集合，网络管理员只需要管理和配置交换端口，而不管交换端口连接什么设备；</li><li>根据mac地址划分，对于每个mac地址，都配置它属于某一个组，它的优点在于，当用户物理位置移动时，即从一个交换机切换到其他交换机时，vlan不需要重新配置；</li><li>基于网络层划分，ip和ipx等，没太理解；</li><li>基于策略划分，比较常用的策略（与厂商设备的支持有关）有：按mac划分，按ip划分，按以太网协议划分，按网络的应用划分等；</li></ol><a id="more"></a><p>  这次实验使用Cisco模拟器实现如下：</p><center><img src="/net191119.png"></center><p>  其中PC0与PC2处于同一个vlan，而PC1和PC3处于同一个vlan；下面给出PC0~3的IP和子网掩码以及所在vlan；</p><ol type="1"><li>PC0：ip：192.168.1.1 mask：255.255.255.0 vlan：100</li><li>PC1：ip：192.168.1.2 mask：255.255.255.0 vlan：200</li><li>PC2：ip：192.168.1.3 mask：255.255.255.0 vlan：100</li><li>PC3：ip：192.168.1.4 mask：255.255.255.0 vlan：200</li></ol><p>  那么显然这四台PC机是在同一个网段中的；</p><p>  先后配置好ip及vlan之后，在PC0上去PingPC1、PC3，是没有响应的，只有PingPC2才会返回数据；之后我又将与PC0处在同一个vlan中的PC2的ip改为192.168.2.3，这样PC0与PC2不在同一个网段，而在同一个vlan中，之后我在PC0上去PingPC2，也没有响应；之后又问了学长，说不同网段是ping不通的，相同网段可以ping通；下面给出总结</p><p>  <strong>只有在相同网段及相同vlan中才能ping的通</strong>，不同网段、不同vlan都不行，那么这是为什么呢，为什么不同网段是ping不通，而相同网段可以ping的通；<strong>这里先留下疑问</strong>;</p><p>  这里我理解的vlan大概是，交换机或路由器对于网络的自主划分，这种划分与划分的方法有关；</p><p>  ICMP协议（网络控制报文协议），在网络层使用；允许主机和路由器报告差错情况和提供有关异常的报告。它的一个重要应用就是分组网间探测PING，用来测试两台主机之间的连通性。关于协议的具体细节暂时省略；</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计算机网络实验&quot;&gt;计算机网络实验&lt;/h2&gt;
&lt;p&gt;  这里主要记录实验中遇到的问题与困惑； ### 第一次实验课19.11.19&lt;/p&gt;
&lt;p&gt;  首先，什么是vlan，vlan即是Virtual Local Area Network，即虚拟局域网，对于处于相同网段的主机来说，它们的ip与对应子网掩码的结果一定相同，而对于处于相同vlan中的不同主机呢；这就涉及到vlan的划分，这里先给出几种划分方法，便于理解vlan；&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;根据端口划分vlan，基于端口的vlan是划分vlan最简单也是最有效的方法，这实际上是某些交换端口的集合，网络管理员只需要管理和配置交换端口，而不管交换端口连接什么设备；&lt;/li&gt;
&lt;li&gt;根据mac地址划分，对于每个mac地址，都配置它属于某一个组，它的优点在于，当用户物理位置移动时，即从一个交换机切换到其他交换机时，vlan不需要重新配置；&lt;/li&gt;
&lt;li&gt;基于网络层划分，ip和ipx等，没太理解；&lt;/li&gt;
&lt;li&gt;基于策略划分，比较常用的策略（与厂商设备的支持有关）有：按mac划分，按ip划分，按以太网协议划分，按网络的应用划分等；&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Networks" scheme="https://yuggu.github.io/categories/Networks/"/>
    
      <category term="Fundmentals" scheme="https://yuggu.github.io/categories/Networks/Fundmentals/"/>
    
    
      <category term="network exper" scheme="https://yuggu.github.io/tags/network-exper/"/>
    
  </entry>
  
  <entry>
    <title>[HDU-4292] Food</title>
    <link href="https://yuggu.github.io/2019/10/28/HDU-4292-Food/"/>
    <id>https://yuggu.github.io/2019/10/28/HDU-4292-Food/</id>
    <published>2019-10-28T07:37:57.000Z</published>
    <updated>2019-10-28T08:26:31.095Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链接">链接</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4292" target="_blank" rel="noopener"><span class="math inline">\(\text{HDU - 4292 Food}\)</span></a></p><h3 id="题意">题意</h3><p>  这里有<span class="math inline">\(N\)</span>个人、然后提供<span class="math inline">\(F\)</span>种食物、<span class="math inline">\(D\)</span>种饮料，并且对于<span class="math inline">\(F\)</span>种食物、<span class="math inline">\(D\)</span>种饮料，仅仅分别提供有限数量<span class="math inline">\(a_i,b_i\)</span>，现在对于<span class="math inline">\(n\)</span>个人，给出每一个人喜欢食物和饮料的编号，现问最多可以可以让多少人感到满足；如果一个人可以获得任意一份他喜欢的食物和任以一份他喜欢的饮料，那么他会感到满足；</p><p>  数据范围：多组测试样例，<span class="math inline">\(1\leq N,M,D\leq 200\)</span>.</p><a id="more"></a><h3 id="分析">分析</h3><p>  这一题需要使用最大流，所以关键部分是怎么建图；</p><p>  对于每个人，我们都已知他喜欢得到的食物和饮料的编号，我们需要给人与饮料、人与食物之间建立边，边权为1（每个人仅需获得一份食物和饮料即可满足）；并且我们想要满足更多的人，而如果一个人能够满足，那么我们可以看成是，有一个流量大小为1的流，按顺序流经食物、人、饮料（或者饮料、人、食物也可以），那么显然的我们需要定义一个起点，这个起点连接所有食物，这样一条边的容量即是该种食物的数量，同样我们需要连接所有饮料到一个汇点，这里就建立起了一个网络流，我们需要求出起点到汇点的最大流量；</p><p>  然而这里还有一些问题，如下图：</p><p><img src="/images/poj3080.PNG"></p><p>  这个图可能存在这样的情况，某一个人可能选择多于1份的食物或者饮料，所以对于任意一个人，我们需要将他看作两个节点，这两个节点相连接，流量为1，这样就能保证整个人最多只能选择一份食物和一份饮料。</p><p>  这题和<a href="http://poj.org/problem?id=3281" target="_blank" rel="noopener">Poj3281</a>几乎是一样的；</p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(a, b) memset(a, b, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,val,pre,next; </span><br><span class="line">&#125;e[<span class="number">3000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt, head[<span class="number">200005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[cnt].pre=x;</span><br><span class="line">    e[cnt].to=y;</span><br><span class="line">    e[cnt].val=w;</span><br><span class="line">    e[cnt].next=head[x];</span><br><span class="line">    head[x]=cnt++;</span><br><span class="line">    e[cnt].pre=y;</span><br><span class="line">    e[cnt].to=x;</span><br><span class="line">    e[cnt].val=<span class="number">0</span>;</span><br><span class="line">    e[cnt].next=head[y];</span><br><span class="line">    head[y]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, f, d, v[<span class="number">200005</span>], dis[<span class="number">200005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; i++)</span><br><span class="line">        dis[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(<span class="number">0</span>);</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i != <span class="number">-1</span>; i=e[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e[i].val &amp;&amp; !dis[e[i].to]) &#123;</span><br><span class="line">                q.push(e[i].to);</span><br><span class="line">                dis[e[i].to] = dis[x] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; dis[e[i].to] &lt;&lt; " " &lt;&lt; e[i].to &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span> (e[i].to == t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> res = flow, k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i != <span class="number">-1</span> &amp;&amp; res; i=e[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = e[i].val, v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (val &amp;&amp; dis[v] == dis[x] + <span class="number">1</span>) &#123;</span><br><span class="line">            k = dinic(v, min(res, val));</span><br><span class="line">            <span class="keyword">if</span> (!k) dis[v] = <span class="number">0</span>;</span><br><span class="line">            e[i].val -= k;</span><br><span class="line">            e[i ^ <span class="number">1</span>].val += k;</span><br><span class="line">            res -= k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow - res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("test.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("test.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; f &gt;&gt; d ) &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        t = <span class="number">2</span> * n + f + d + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; i++)</span><br><span class="line">            head[i]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= f; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            add(<span class="number">0</span>, <span class="number">2</span> * n + i, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            add(f + <span class="number">2</span> * n + i, t, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">            add(i, n + i, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= f; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j - <span class="number">1</span>] == <span class="string">'Y'</span>) add(<span class="number">2</span> * n + j, i, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= d; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j - <span class="number">1</span>] == <span class="string">'Y'</span>) </span><br><span class="line">                    add(n + i, n + n + f + j, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>, maxflow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (bfs()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flow = dinic(<span class="number">0</span>, inf)) maxflow += flow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; maxflow &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;链接&quot;&gt;链接&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=4292&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\(\text{HDU - 4292 Food}\)&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题意&quot;&gt;题意&lt;/h3&gt;
&lt;p&gt;  这里有&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;个人、然后提供&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;种食物、&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;种饮料，并且对于&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;种食物、&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;种饮料，仅仅分别提供有限数量&lt;span class=&quot;math inline&quot;&gt;\(a_i,b_i\)&lt;/span&gt;，现在对于&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个人，给出每一个人喜欢食物和饮料的编号，现问最多可以可以让多少人感到满足；如果一个人可以获得任意一份他喜欢的食物和任以一份他喜欢的饮料，那么他会感到满足；&lt;/p&gt;
&lt;p&gt;  数据范围：多组测试样例，&lt;span class=&quot;math inline&quot;&gt;\(1\leq N,M,D\leq 200\)&lt;/span&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="网络流" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="最大流" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/%E7%BD%91%E7%BB%9C%E6%B5%81/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
    
      <category term="最大流" scheme="https://yuggu.github.io/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="网络流" scheme="https://yuggu.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>[POJ 3080] Blue Jeans</title>
    <link href="https://yuggu.github.io/2019/10/28/POJ-3080-Blue-Jeans/"/>
    <id>https://yuggu.github.io/2019/10/28/POJ-3080-Blue-Jeans/</id>
    <published>2019-10-28T05:12:12.000Z</published>
    <updated>2019-10-28T08:26:21.349Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链接">链接</h3><p><a href="http://poj.org/problem?id=3080" target="_blank" rel="noopener"><span class="math inline">\(\text{POJ - 3080 Blue Jeans}\)</span></a></p><h3 id="题意">题意</h3><p>  给你<span class="math inline">\(m\)</span>个长度为60字符串，求它们的最长公共子串，如果有多个最长公共子串，输出字典序最小的，如果不存在或者最长公共子串的长度小于3则输出<code>no significant commonalities</code>；</p><p>  数据范围：共<span class="math inline">\(n\)</span>组测试样例，每组一个<span class="math inline">\(m\)</span>，<span class="math inline">\(2\leq m\leq 10\)</span>.</p><h3 id="分析">分析</h3><p>  由于数据范围比较小，我们可以<span class="math inline">\(kmp+\)</span>暴力，假如<span class="math inline">\(m\)</span>个串的集合为<span class="math inline">\(s\)</span>，那么我们枚举<span class="math inline">\(s[0]\)</span>的所有长度<span class="math inline">\(\geq\)</span> 3的所有子串，那么答案存在，必为其中的某一个，我们枚举这些子串，看对于一个子串是否能够同时和<span class="math inline">\(s[1\dots m]\)</span>进行匹配成功，我们可以将得到的<span class="math inline">\(s\)</span>集合排个序，使得我们找到一个可以与<span class="math inline">\(s[1\dots m]\)</span>所有串匹配的子串，就可以直接输出它；</p><a id="more"></a><p>  这里我用的java，对于s集合中串的排序，c++里的我们可以写一个compare函数作为sort函数的第三个参数，对于java是有点类似的，见代码。</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.Integer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Messick on 2019/10/26.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> [] next = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">105</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        PrintWriter out = <span class="keyword">new</span> PrintWriter(System.out);</span><br><span class="line">        <span class="keyword">int</span> t = input.nextInt();</span><br><span class="line">        <span class="keyword">while</span> (t-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">            n--;</span><br><span class="line">            String s = input.next();</span><br><span class="line">            Vector&lt;String&gt; v = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">            <span class="keyword">int</span> len = s.length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">3</span>;j &lt;= len; j++)</span><br><span class="line">                    v.add(s.substring(i, j));</span><br><span class="line">            Collections.sort(v, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (o1.length() == o2.length())<span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">                    <span class="keyword">if</span> (o1.length() &lt; o2.length()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"><span class="comment">//            for (int i = 0; i &lt; v.size();i++)</span></span><br><span class="line"><span class="comment">//                System.out.println(v.get(i));</span></span><br><span class="line">            String [] so = <span class="keyword">new</span> String [<span class="number">15</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                so[i] = input.next();</span><br><span class="line">            <span class="keyword">int</span> flag = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++) &#123;</span><br><span class="line">                flag = i;</span><br><span class="line">                kmp(v.get(i));</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (match(so[j], v.get(i)))<span class="keyword">continue</span>;</span><br><span class="line">                    flag = -<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag != -<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag == -<span class="number">1</span>)System.out.println(<span class="string">"no significant commonalities"</span>);</span><br><span class="line">            <span class="keyword">else</span> System.out.println(v.get(flag));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kmp</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Arrays.fill(next, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> l = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= l; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - <span class="number">1</span>) != s.charAt(j)) j = next[j];</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == s.charAt(j))j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = s1.length(), l2 = s2.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= l1; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; (j == l2 || s1.charAt(i - <span class="number">1</span>) != s2.charAt(j)))j = next[j];</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i - <span class="number">1</span>) == s2.charAt(j))j++;</span><br><span class="line">            <span class="keyword">if</span> (j == l2)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;链接&quot;&gt;链接&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=3080&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\(\text{POJ - 3080 Blue Jeans}\)&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题意&quot;&gt;题意&lt;/h3&gt;
&lt;p&gt;  给你&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;个长度为60字符串，求它们的最长公共子串，如果有多个最长公共子串，输出字典序最小的，如果不存在或者最长公共子串的长度小于3则输出&lt;code&gt;no significant commonalities&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;  数据范围：共&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;组测试样例，每组一个&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(2\leq m\leq 10\)&lt;/span&gt;.&lt;/p&gt;
&lt;h3 id=&quot;分析&quot;&gt;分析&lt;/h3&gt;
&lt;p&gt;  由于数据范围比较小，我们可以&lt;span class=&quot;math inline&quot;&gt;\(kmp+\)&lt;/span&gt;暴力，假如&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;个串的集合为&lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt;，那么我们枚举&lt;span class=&quot;math inline&quot;&gt;\(s[0]\)&lt;/span&gt;的所有长度&lt;span class=&quot;math inline&quot;&gt;\(\geq\)&lt;/span&gt; 3的所有子串，那么答案存在，必为其中的某一个，我们枚举这些子串，看对于一个子串是否能够同时和&lt;span class=&quot;math inline&quot;&gt;\(s[1\dots m]\)&lt;/span&gt;进行匹配成功，我们可以将得到的&lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt;集合排个序，使得我们找到一个可以与&lt;span class=&quot;math inline&quot;&gt;\(s[1\dots m]\)&lt;/span&gt;所有串匹配的子串，就可以直接输出它；&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="kmp" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/kmp/"/>
    
    
      <category term="字符串" scheme="https://yuggu.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="kmp" scheme="https://yuggu.github.io/tags/kmp/"/>
    
  </entry>
  
  <entry>
    <title>I/O流</title>
    <link href="https://yuggu.github.io/2019/10/25/I-O%E6%B5%81/"/>
    <id>https://yuggu.github.io/2019/10/25/I-O流/</id>
    <published>2019-10-25T11:26:28.000Z</published>
    <updated>2019-11-16T05:33:53.722Z</updated>
    
    <content type="html"><![CDATA[<h3 id="缓冲区">缓冲区</h3><p>  遇到与底层相关的概念，往往都很模糊，所以才想要把这个问题解决清楚；</p><p>  那么什么是缓冲区呢，我为什么会有这样的疑问呢；接触到Java的I/O流，其中底层是怎么实现的，其中BufferedReader中的Buffered是什么意思，C语言中的输入、输出底层是什么实现的，它们跟缓冲有什么关系；</p><p>  缓冲区（Buffer）就是在内存中预留指定大小的存储空间用来对I/O的数据做临时存储，这部分预留的内存空间叫缓冲区。</p><p>  对于scanf()来说，它是从缓冲区里读取数据到对应的变量里，如果缓冲区没有数据，这时候执行scanf()，它会因读取不到数据而一直等待，从而发生死锁；</p><a id="more"></a><h3 id="java-file类">Java File类</h3><p>  在java中，File对象是一个对文件或者目录名的抽象，在windows中即是文件夹，它不是真实硬盘里的文件或者文件夹，File实例是在内存中new出来的一个对象，实际上它只是 与硬盘上的文件或者文件夹进行了映射，它的构造函数参见<a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">File类构造函数</a>，他不含有无参的构造函数，即它这个new出来的对象，根据构造函数参数代表的文件进行映射，如果文件不存在，那么对于这个file实例来说，它不会发生错误，它的属性依然拥有默认值，不过当如果通过流去读取时，会发生错误；构造函数参数文件名，不区分大小写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;  </span><br><span class="line"><span class="keyword">import</span> java.util.*;  </span><br><span class="line"><span class="keyword">import</span> java.lang.Integer;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Created by Messick on 2019/10/26. */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"D:\\1.txt"</span>);  </span><br><span class="line">        System.out.println(file.canExecute());  </span><br><span class="line">        System.out.println(file.canRead());  </span><br><span class="line">        System.out.println(file.canWrite());  </span><br><span class="line">        System.out.println(file.isHidden());  </span><br><span class="line">        System.out.println(file.isFile());  </span><br><span class="line">        System.out.println(file.isDirectory());  </span><br><span class="line">        System.out.println(file.length());</span><br><span class="line">        System.out.println(file.lastModified());</span><br><span class="line">        File file1 = <span class="keyword">new</span> File(<span class="string">"D:\\2.txt"</span>);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">boolean</span> v1 = file1.createNewFile();  </span><br><span class="line">            System.out.println(v1);  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        File file2 = <span class="keyword">new</span> File(<span class="string">"D:\\3"</span>);  </span><br><span class="line">        File file3 = <span class="keyword">new</span> File(<span class="string">"D:\\l1\\l2"</span>);  </span><br><span class="line">        System.out.println(file2.mkdir());  </span><br><span class="line">        <span class="comment">//递归创建文件夹</span></span><br><span class="line">        System.out.println(file3.mkdirs());</span><br><span class="line">        System.out.println(file1.delete());  </span><br><span class="line">        System.out.println(file2.delete()); </span><br><span class="line">        <span class="comment">//删除文件或空文件夹 </span></span><br><span class="line">        System.out.println(file3.delete());</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java-文件流">Java 文件流</h3><p>  分为字节型文件流和字符型文件流；</p><p>  文件存在的原因，是因为文件存储在硬盘上，是永久保存的，而类似变量、集合，都是暂时性地存储，并且文件可以存储很多份地信息。</p><p>  对于文件的读取，实际上是将文件里的信息读取，存到内存中的集合等容器中，然后对此容器进行操作，此容器相当于缓存。而文件流即是对于文件的读取或者写入。</p><h4 id="字节型文件流">字节型文件流</h4><p>  FileInputStream/FileOutputStream</p><ol type="1"><li>FileInputStream是InputStream的子类，字节型输入流都是InputStream的子类。它的构造函数有三个，分别是字符串、file对象，第三个不做了解；</li><li>FileInputStream.read()，java对该方法进行了重载，对于不带参数的方法，为读取一个字节，返回值为读取字节对应的Unicode；实际上都是当作字符来读取，如果读取到汉字，而汉字编码又不是一个字节的情况下，那么仅读取该汉字的一字节的数据，如果输出这个单字节数据的Unicode码对应的char，可能会是乱码；对于带参数的情况，参数可以是一个byte数组，即一次性读取byte数组大小的数据，并存到该byte数组中；</li></ol><p>  如图，使用一个3字节大小的byte数组去成功读取一个汉字，所以，可以想到的是，如果我们去读取1字节，那么仅仅是该汉字的一部分；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;  </span><br><span class="line"><span class="keyword">import</span> java.util.*;  </span><br><span class="line"><span class="keyword">import</span> java.lang.Integer;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Created by Messick on 2019/10/26. */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"D:\\1.txt"</span>);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);  </span><br><span class="line">            <span class="comment">//读取一个字节 返回为读取字节int的Unicode码  </span></span><br><span class="line">            <span class="keyword">int</span> t = fis.read(); </span><br><span class="line">            <span class="comment">//byte [] a = new byte[10003];</span></span><br><span class="line">            <span class="comment">////文件读取到byte数组里,cnt为读取到的有效字节个数，包括\r\n</span></span><br><span class="line">            <span class="comment">//int cnt  = fis.read(a);  </span></span><br><span class="line">            <span class="comment">//for(byte x:a) &#123;  </span></span><br><span class="line">            <span class="comment">//    System.out.println(x);</span></span><br><span class="line">            <span class="comment">//    流管道中剩余的缓存的字节数</span></span><br><span class="line">            <span class="comment">//    System.out.println(fis.available());  </span></span><br><span class="line">            <span class="comment">//&#125; </span></span><br><span class="line">            <span class="keyword">while</span> (t != -<span class="number">1</span>) &#123;  </span><br><span class="line">                <span class="comment">//字节对应的Unicode码  </span></span><br><span class="line">                System.out.println(t);  </span><br><span class="line">                t = fis.read();  </span><br><span class="line">                <span class="comment">//这个过程中，流管道中缓存的字节数逐渐减少至0</span></span><br><span class="line">                System.out.println(fis.available());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 需要注意的是，在文件中，每一行的结尾一定是\r\n，分别代表换行符和回车，对应的Unicode码为13、10 */</span></span><br></pre></td></tr></table></figure><p>  同FileInputStream，FileOutputStream是OutputStream的子类，字节型输出流都是OutputStream的子类；在这里，如果创建文件输出流，文件路径不存在，则创建该文件；对于FileInputStream则会抛出异常；<strong>并且，FileOutputStream实例含有一个两个参数的构造函数，第一个参数为文件路径，第二个参数为一个布尔型，为true代表可追加，否则每次新建一个文件输出流，文件内容都会被清空。</strong></p><ol type="1"><li>FileOutputStream，该类构造函数第一种，参数为File类实例，还有一个boolean参数 默认false，第二种构造函数和第一种类似，不过把File换成了String；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;  </span><br><span class="line"><span class="keyword">import</span> java.util.*;  </span><br><span class="line"><span class="keyword">import</span> java.lang.Integer;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Created by Messick on 2019/10/26. */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"D:\\1.txt"</span>);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">// 流管道  </span></span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file,<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">byte</span> [] b = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;;</span><br><span class="line">            String str = <span class="string">"1 + 1 = 2"</span>;</span><br><span class="line">            fos.write(b);</span><br><span class="line">            fos.write(str.getBytes());</span><br><span class="line">            fos.write(<span class="number">102</span>);  </span><br><span class="line">            fos.write(<span class="number">103</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符型文件流">字符型文件流</h4><p>  FileReader/FileWriter；</p><ol type="1"><li><p>FileReader是字符型文件输入流，是InputStreamReader的子类，而InputStreamReader是Reader的子类，它含有两个构造函数，第一种，含一个参数是String，即文件路径，第二种参数是一个File实例；</p></li><li><p>FileReader.read()，对于它不含参数的方法，读取一个字符，返回值为该字符的Unicode码；对于含参数的方法，它的参数应该是一个空的char数组，即将通过流将文件中字符读到char数组中，返回值为读取的有效字符数；</p></li><li><p>FileWriter，常用方法，FileWriter.wirte()，参数可以是你想要写到文件里的字符对应的Unicode码，或者是一个字符数组，或者是一个String，不能是字符；</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;  </span><br><span class="line"><span class="keyword">import</span> java.util.*;  </span><br><span class="line"><span class="keyword">import</span> java.lang.Integer;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Created by Messick on 2019/10/26. */</span><span class="comment">//你哈珀  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">"D:\\1.txt"</span>);  </span><br><span class="line">            FileReader fr = <span class="keyword">new</span> FileReader(file);  </span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);  </span><br><span class="line">            FileWriter fw = <span class="keyword">new</span> FileWriter(file, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">int</span> code = fr.read();  </span><br><span class="line">            System.out.println((<span class="keyword">char</span>)code);  </span><br><span class="line">        &#125; <span class="keyword">catch</span>(FileNotFoundException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java-缓冲流">Java 缓冲流</h3><p>  同样的，也分为字节型缓冲流和字符型缓冲流，BufferedInputStream/BufferedOutputStream，BufferedReader/BufferedWriter；</p><p>  使用缓冲的目的即是为了提高速度，比如，一次读取很多字节，但不写入磁盘，先放到内存中，等凑够了缓冲区的大小一次性写入磁盘，这样减少了磁盘操作次数，会提高速度；</p><p>  所以，缓冲流就是实现了缓冲功能的输入流和输出流，使用带缓冲的输入输出流，效率更高速度更快。</p><p>  <code>BufferedInputStream/BufferedOutputStream</code>本质上是通过一个内部缓冲字节数组实现的，那么<code>BufferedReader/BufferedWriter</code>本质上是通过一个内部缓冲字符数组实现的。具体参见java API；</p><p>  需要注意，缓冲流的构造函数的参数需要是一个文件流的实例；</p><h3 id="java序列化与反序列化">Java序列化与反序列化</h3><p>  之前学过了也讲过了<span class="math inline">\(\dots\)</span></p><h3 id="待续">待续</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;缓冲区&quot;&gt;缓冲区&lt;/h3&gt;
&lt;p&gt;  遇到与底层相关的概念，往往都很模糊，所以才想要把这个问题解决清楚；&lt;/p&gt;
&lt;p&gt;  那么什么是缓冲区呢，我为什么会有这样的疑问呢；接触到Java的I/O流，其中底层是怎么实现的，其中BufferedReader中的Buffered是什么意思，C语言中的输入、输出底层是什么实现的，它们跟缓冲有什么关系；&lt;/p&gt;
&lt;p&gt;  缓冲区（Buffer）就是在内存中预留指定大小的存储空间用来对I/O的数据做临时存储，这部分预留的内存空间叫缓冲区。&lt;/p&gt;
&lt;p&gt;  对于scanf()来说，它是从缓冲区里读取数据到对应的变量里，如果缓冲区没有数据，这时候执行scanf()，它会因读取不到数据而一直等待，从而发生死锁；&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://yuggu.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="java I/O" scheme="https://yuggu.github.io/tags/java-I-O/"/>
    
      <category term="I/O" scheme="https://yuggu.github.io/tags/I-O/"/>
    
      <category term="缓冲区" scheme="https://yuggu.github.io/tags/%E7%BC%93%E5%86%B2%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>[Luogu-P3375] KMP字符串匹配</title>
    <link href="https://yuggu.github.io/2019/10/24/Luogu-P3375-KMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    <id>https://yuggu.github.io/2019/10/24/Luogu-P3375-KMP字符串匹配/</id>
    <published>2019-10-24T12:41:57.000Z</published>
    <updated>2019-10-28T05:11:13.154Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链接">链接</h3><p><a href="https://www.luogu.org/problem/P3375" target="_blank" rel="noopener"><span class="math inline">\(\text{Luogu-P3375 KMP字符串匹配}\)</span></a></p><h3 id="题意">题意</h3><p>  输入两个串<span class="math inline">\(s_1、s_2\)</span>，求出<span class="math inline">\(s_2\)</span>在<span class="math inline">\(s_1\)</span>中所有出现的位置（匹配的开始位置），并输出子串的<span class="math inline">\(next\)</span>数组的；</p><p>  数据范围：<span class="math inline">\(s_1\)</span>长度为<span class="math inline">\(n\)</span>，<span class="math inline">\(s_2\)</span>长度为<span class="math inline">\(M\)</span>，<span class="math inline">\(n\leq 1000000,m\leq 1000000\)</span>.</p><h3 id="分析">分析</h3><p>  这是一个<span class="math inline">\(kmp\)</span>的模板题；</p><p>  这里我用了<span class="math inline">\(Java\)</span>来写，然而一直TLE，不知什么原因，最后发现了原因，在于String的使用；</p><p>  在<span class="math inline">\(ACM\)</span>竞赛中需要特别注意Java中String及与其有关的一些函数；String是一个不可变的对象，每次对String进行修改时都等同于生成了一个新的String临时对象，如果需要经常对其修改，那么这是相当浪费时间的；</p><p>  在此题中，我使用了一个String.format()函数来控制格式的输出，这个函数会返回一个String，而我又在for里反复使用了它，所以会TLE；我试了仅仅使用String.format()输出了一个元素，是不会超时的，所以仅仅是<span class="math inline">\(O(1)\)</span>的使用它是不会超时的。</p><a id="more"></a><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;  </span><br><span class="line"><span class="keyword">import</span> java.util.*;  </span><br><span class="line"><span class="keyword">import</span> java.lang.*;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> [] next = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000003</span>];  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n, m;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Scanner input =<span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));  </span><br><span class="line">        PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedOutputStream(System.out));  </span><br><span class="line">        String s1 = input.nextLine(), s2 = input.nextLine();  </span><br><span class="line">        n = s1.length();  </span><br><span class="line">        m = s2.length();  </span><br><span class="line">        kmp(s2);  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++) &#123;  </span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; (j == m || s1.charAt(i - <span class="number">1</span>) != s2.charAt(j)))j = next[j];  </span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i - <span class="number">1</span>) == s2.charAt(j)) &#123;  </span><br><span class="line">                j++;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;  </span><br><span class="line">                out.println(i - j + <span class="number">1</span>);  </span><br><span class="line">                <span class="comment">// 在s1中，和s2匹配的各串之间可以覆盖  </span></span><br><span class="line">                j = next[j];  </span><br><span class="line">                <span class="comment">// j = 0 在s1中，和s2匹配的各串之间可以覆盖  </span></span><br><span class="line">                <span class="comment">// 即下一个匹配的串的开始位置，必须在上一个匹配的串的结束位置的后面  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m - <span class="number">1</span>; i++) &#123;  </span><br><span class="line">           out.print(next[i] + <span class="string">" "</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        out.println(String.format(<span class="string">"%d"</span>,next[m]));  </span><br><span class="line">        out.flush();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kmp</span><span class="params">(String s)</span> </span>&#123;  </span><br><span class="line">        next[<span class="number">1</span>] = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++) &#123;  </span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - <span class="number">1</span>) != s.charAt(j)) j = next[j];  </span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == s.charAt(j)) j++;  </span><br><span class="line">            next[i] = j;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;链接&quot;&gt;链接&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problem/P3375&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\(\text{Luogu-P3375 KMP字符串匹配}\)&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题意&quot;&gt;题意&lt;/h3&gt;
&lt;p&gt;  输入两个串&lt;span class=&quot;math inline&quot;&gt;\(s_1、s_2\)&lt;/span&gt;，求出&lt;span class=&quot;math inline&quot;&gt;\(s_2\)&lt;/span&gt;在&lt;span class=&quot;math inline&quot;&gt;\(s_1\)&lt;/span&gt;中所有出现的位置（匹配的开始位置），并输出子串的&lt;span class=&quot;math inline&quot;&gt;\(next\)&lt;/span&gt;数组的；&lt;/p&gt;
&lt;p&gt;  数据范围：&lt;span class=&quot;math inline&quot;&gt;\(s_1\)&lt;/span&gt;长度为&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(s_2\)&lt;/span&gt;长度为&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(n\leq 1000000,m\leq 1000000\)&lt;/span&gt;.&lt;/p&gt;
&lt;h3 id=&quot;分析&quot;&gt;分析&lt;/h3&gt;
&lt;p&gt;  这是一个&lt;span class=&quot;math inline&quot;&gt;\(kmp\)&lt;/span&gt;的模板题；&lt;/p&gt;
&lt;p&gt;  这里我用了&lt;span class=&quot;math inline&quot;&gt;\(Java\)&lt;/span&gt;来写，然而一直TLE，不知什么原因，最后发现了原因，在于String的使用；&lt;/p&gt;
&lt;p&gt;  在&lt;span class=&quot;math inline&quot;&gt;\(ACM\)&lt;/span&gt;竞赛中需要特别注意Java中String及与其有关的一些函数；String是一个不可变的对象，每次对String进行修改时都等同于生成了一个新的String临时对象，如果需要经常对其修改，那么这是相当浪费时间的；&lt;/p&gt;
&lt;p&gt;  在此题中，我使用了一个String.format()函数来控制格式的输出，这个函数会返回一个String，而我又在for里反复使用了它，所以会TLE；我试了仅仅使用String.format()输出了一个元素，是不会超时的，所以仅仅是&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;的使用它是不会超时的。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="kmp" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/kmp/"/>
    
    
      <category term="字符串" scheme="https://yuggu.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="kmp" scheme="https://yuggu.github.io/tags/kmp/"/>
    
  </entry>
  
  <entry>
    <title>[ABC143] E.Travel by Car</title>
    <link href="https://yuggu.github.io/2019/10/22/ABC143-E.Travel-by-Car/"/>
    <id>https://yuggu.github.io/2019/10/22/ABC143-E.Travel-by-Car/</id>
    <published>2019-10-22T13:33:51.000Z</published>
    <updated>2019-10-24T06:55:15.304Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链接">链接</h3><p><a href="https://atcoder.jp/contests/abc143/tasks/abc143_e" target="_blank" rel="noopener"><span class="math inline">\(\text{ABC143 E - Travel by Car}\)</span></a></p><h3 id="题意">题意</h3><p>  给你一个由<span class="math inline">\(n\)</span>个城镇（编号<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>）和<span class="math inline">\(m\)</span>条路组成的无向图，第<span class="math inline">\(i\)</span>条路的距离为<span class="math inline">\(C_i\)</span>； 你将要乘车去一些城镇旅游，你的汽车的油箱的容量是<span class="math inline">\(L\)</span>，在路上行驶<span class="math inline">\(1\)</span>单位的距离将消耗<span class="math inline">\(1\)</span>单位的油，在你旅游途中的每个城镇，你都可以选择加油与不加油，选择加油，你可以将你油箱加满油；现在将对你进行<span class="math inline">\(Q\)</span>次询问，每次询问从城镇<span class="math inline">\(S_i\)</span>到城镇<span class="math inline">\(T_i\)</span>，旅途中的最少加油次数，如果不能抵达输出<span class="math inline">\(-1\)</span>；</p><p>  数据范围：<span class="math inline">\(2\leq n\leq 300,0\leq M\leq \frac{n(n-1)}{2},1\leq L\leq 10^{9}，S_i\neq T_i,1\leq C_i\leq 10^{9},1\leq Q\leq N(N-1)\)</span>.</p><a id="more"></a><h3 id="分析">分析</h3><p>  这里的查询最多可以有<span class="math inline">\(N(N-1)\)</span>个，所以我们考虑预处理出任意两点之间的答案；</p><p>  首先可以寻找出所有的起始终止城镇<span class="math inline">\((s_i,t_i)\)</span>，使得从<span class="math inline">\(s_i\)</span>到<span class="math inline">\(t_i\)</span>加一次油即可到达，可以通过计算任意两点之间的最短路得出，然后我们在此基础上处理，若两个 城镇之间距离<span class="math inline">\(\leq L\)</span>，那么它们之间仅加一次油即可，所以将该条边权值赋为<span class="math inline">\(1\)</span>，若<span class="math inline">\(&gt;L\)</span>则赋值为<span class="math inline">\(\infty\)</span>，由此计算任意两城镇之间最短路，此时的最短路，即是最少加油次数；</p><p>  对于任意<span class="math inline">\((s_i,t_i)\)</span>，我们都贪心的考虑，将路径分割成若干段，每一段距离都<span class="math inline">\(\leq L\)</span>，我们希望得到尽量少的段，所以我们预处理了任意两城市之间的最短路；</p><p>  注意开始油箱是满的；</p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, l, q, cost[<span class="number">304</span>][<span class="number">305</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("test.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("test.out", "w", stdout);</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; l;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    clr(cost, inf);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        cost[a][b] = cost[b][a] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    floyd();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            cost[i][j] = (cost[i][j] &lt;= l ? <span class="number">1</span> : inf);</span><br><span class="line">    floyd();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (cost[a][b] == inf ? <span class="number">-1</span> : cost[a][b] - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;链接&quot;&gt;链接&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://atcoder.jp/contests/abc143/tasks/abc143_e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\(\text{ABC143 E - Travel by Car}\)&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题意&quot;&gt;题意&lt;/h3&gt;
&lt;p&gt;  给你一个由&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个城镇（编号&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;到&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;）和&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;条路组成的无向图，第&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;条路的距离为&lt;span class=&quot;math inline&quot;&gt;\(C_i\)&lt;/span&gt;； 你将要乘车去一些城镇旅游，你的汽车的油箱的容量是&lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt;，在路上行驶&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;单位的距离将消耗&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;单位的油，在你旅游途中的每个城镇，你都可以选择加油与不加油，选择加油，你可以将你油箱加满油；现在将对你进行&lt;span class=&quot;math inline&quot;&gt;\(Q\)&lt;/span&gt;次询问，每次询问从城镇&lt;span class=&quot;math inline&quot;&gt;\(S_i\)&lt;/span&gt;到城镇&lt;span class=&quot;math inline&quot;&gt;\(T_i\)&lt;/span&gt;，旅途中的最少加油次数，如果不能抵达输出&lt;span class=&quot;math inline&quot;&gt;\(-1\)&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;  数据范围：&lt;span class=&quot;math inline&quot;&gt;\(2\leq n\leq 300,0\leq M\leq \frac{n(n-1)}{2},1\leq L\leq 10^{9}，S_i\neq T_i,1\leq C_i\leq 10^{9},1\leq Q\leq N(N-1)\)&lt;/span&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python程序随笔:191016</title>
    <link href="https://yuggu.github.io/2019/10/16/python%E7%A8%8B%E5%BA%8F%E9%9A%8F%E7%AC%94-191016/"/>
    <id>https://yuggu.github.io/2019/10/16/python程序随笔-191016/</id>
    <published>2019-10-16T11:24:14.000Z</published>
    <updated>2019-10-17T06:30:31.912Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现文件的自动分类">实现文件的自动分类</h3><h4 id="程序的实现">程序的实现</h4><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os  </span><br><span class="line"><span class="keyword">import</span> shutil  </span><br><span class="line">  </span><br><span class="line">path = <span class="string">'C:\\Users\\19143\\Desktop\\test\\'</span>  </span><br><span class="line">files = os.listdir(path)  </span><br><span class="line">print(files)  </span><br><span class="line">folder_list = []  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> files:  </span><br><span class="line">    <span class="comment"># 连接目录与文件名得到绝对路径，这里的path需要使用绝对路径，不然程序会自动到python程序路径下寻找</span></span><br><span class="line">    <span class="comment"># 所以也可以把文件放在python程序路径下</span></span><br><span class="line">    f_absolute_path = path + f</span><br><span class="line">    <span class="comment"># 如果是文件夹就单独处理，把它的路径记录下来  </span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isfile(f_absolute_path):  </span><br><span class="line">        folder_list.append(f_absolute_path)  </span><br><span class="line">        <span class="keyword">continue</span>  </span><br><span class="line">    <span class="comment"># folder_name即是一个以f文件后缀名来命名的文件夹的绝对路径</span></span><br><span class="line">    folder_name = path + f.split(<span class="string">'.'</span>)[<span class="number">-1</span>]  </span><br><span class="line">    <span class="comment"># print(folder_name)  </span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(folder_name):  </span><br><span class="line">        <span class="comment"># 该文件夹不存在，就创建</span></span><br><span class="line">        os.makedirs(folder_name)  </span><br><span class="line">        shutil.move(f_absolute_path, folder_name)  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        shutil.move(f_absolute_path, folder_name)  </span><br><span class="line">  </span><br><span class="line">print(folder_list)  </span><br><span class="line"><span class="keyword">if</span> len(folder_list) &gt; <span class="number">1</span>:</span><br><span class="line">    <span class="comment"># 在path目录下创建一个名称为'all_folder'的文件夹  </span></span><br><span class="line">    new_folder_path = path + <span class="string">'all_folder'</span>  </span><br><span class="line">    os.mkdir(new_folder_path)  </span><br><span class="line">    print(new_folder_path)  </span><br><span class="line">    <span class="keyword">for</span> folder <span class="keyword">in</span> folder_list:  </span><br><span class="line">        print(folder)  </span><br><span class="line">        <span class="comment"># 将path路径下的文件夹放入，all_folder下，(不包括以后缀名分类创建的文件夹)</span></span><br><span class="line">        shutil.move(folder, new_folder_path)</span><br></pre></td></tr></table></figure><h4 id="遇到的问题">遇到的问题</h4><ul><li>os.path.isfile()用来判断是文件还是文件夹，os.path.isdir()用来判断是不是目录</li><li>os.path.abspath()用来获取文件或目录的绝对路径，目录的绝对路径包含它本身这一级</li><li>os.mkdir()只能创建一级目录，os.makedirs()可以递归创建目录</li><li>os.rmdir()为删除目录，它只能删空目录，shutil.rmtree()可以递归删除非空目录，另外os.remove()用来删除文件，若路径指定文件不存在会报错</li></ul><h3 id="取出一个文件夹内所有文件包括子文件夹">取出一个文件夹内所有文件（包括子文件夹）</h3><h4 id="程序实现">程序实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os  </span><br><span class="line"><span class="keyword">import</span> shutil  </span><br><span class="line">  </span><br><span class="line">path = <span class="string">'C:\\Users\\19143\\Desktop\\steamcommunity_302_V8_hotfix\\'</span>  </span><br><span class="line"><span class="comment"># error  </span></span><br><span class="line"><span class="comment"># new_path = 'C:\\Users\\19143\\Desktop\\steamcommunity_302_V8_hotfix\\all_files\\'  </span></span><br><span class="line">  </span><br><span class="line">new_path = <span class="string">'C:\\Users\\19143\\Desktop\\all_files'</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(new_path):  </span><br><span class="line">    os.mkdir(new_path)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> roots, dirs, files <span class="keyword">in</span> os.walk(path):  </span><br><span class="line">    <span class="comment">#（逃） if not roots.endswith('\\'):  </span></span><br><span class="line">    <span class="comment">#（逃）    roots += '\\'  </span></span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> files:  </span><br><span class="line">        print(roots,<span class="string">'\t'</span>,f,<span class="string">'\t'</span>,dirs)  </span><br><span class="line">        <span class="comment"># shutil.move(f, new_path)  </span></span><br><span class="line">    shutil.copy(os.path.join(roots, f), new_path)</span><br></pre></td></tr></table></figure><h4 id="遇到的问题-1">遇到的问题</h4><ul><li><p>本来我是想dfs搜索所有文件夹的，然而我发现了os.walk()这个方便的函数，<strong>嗯，真香</strong>os.walk(top[,topdown=True[,onerror=None[,followlinks=False]]])是一个简单易用的文件、目录遍历器，帮助我们高效处理文件目录方面的事情，top为所要遍历的目录的地址，topdown为真优先遍历top目录，否则优先遍历子目录，followlinks为真，会遍历快捷方式实际所指目录；它的返回值是一个生成器，所以我们需要不断的遍历它，来获得我们需要的信息，每次遍历的对象都是返回的是一个三元组(root,dirs,files)</p><ol type="1"><li>root指的是当前正在遍历的这个文件夹的本身的绝对路径</li><li>dirs是一个list，内容是当前遍历文件夹里的所有的文件夹的名称（不包含子目录）</li><li>files也是list，内容是当前遍历文件夹里的所有文件的名称（不含子目录，且包含后缀名）</li></ol></li><li><p>注意os.path.join(path,file)的使用，之前我没用这个，我写的我给注释了，<strong>真的丑</strong></p></li><li><ul><li>shutil.move()与shutil.copy()函数，使用需要注意这个问题，它们分辨两个文件的方法是看它们的路径，即同一个文件分别放到两个不同路径下得到两个文件，这两个函数把这两个文件看成不同文件；<strong>另外，如果你把test文件夹下的文件test，使用shutil.move()移动或使用shutil.copy()复制到test文件夹下，即把某目录下的文件移动或复制到该目录下，这两种操作对于这两个函数都是不行的，会报错</strong>，如下面那张图片所示；</li></ul></li><li><p>关于你想要把文件保存到哪个文件夹，在这里即是new_path，这个new_path不能是path的子目录；有这样一种情况，假如path下直接有一个文件test，也有你的new_path，你遍历path下的文件，把test包括其他所有文件（不包括子目录）放入new_path中，然后os.walk()便开始遍历path子目录，比如new_path，（实际上，new_path你是不希望被访问的，它是专门用来存放文件的）。然后你遍历new_path中的文件，比如test，你就又访问了一次这个文件，然后复制test放入new_path中；然后它就会报错，比如：</p></li></ul><p><img src="/images/py191017.png" width="800px"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;实现文件的自动分类&quot;&gt;实现文件的自动分类&lt;/h3&gt;
&lt;h4 id=&quot;程序的实现&quot;&gt;程序的实现&lt;/h4&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://yuggu.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Python" scheme="https://yuggu.github.io/tags/Python/"/>
    
      <category term="随笔" scheme="https://yuggu.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>2019牛客多校第一场</title>
    <link href="https://yuggu.github.io/2019/10/13/2019%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA/"/>
    <id>https://yuggu.github.io/2019/10/13/2019牛客多校第一场/</id>
    <published>2019-10-13T07:29:41.000Z</published>
    <updated>2019-10-16T10:35:19.630Z</updated>
    
    <content type="html"><![CDATA[<h3 id="e.-abba">E. ABBA</h3><h4 id="题意">题意：</h4><p>  你拥有一个长度为<span class="math inline">\(2*(n+m)\)</span>的字符串，它含有<span class="math inline">\(n+m\)</span>个<span class="math inline">\(A\)</span>，以及<span class="math inline">\(n+m\)</span>个<span class="math inline">\(B\)</span>，你把个字符串给分解，最后可以得到<span class="math inline">\(n\)</span>个子序列<span class="math inline">\(AB\)</span>与<span class="math inline">\(m\)</span>个子序列<span class="math inline">\(BA\)</span>，问这个字符串有多少种，最终结果对（<span class="math inline">\(10^9+7\)</span>）取余；比如<span class="math inline">\(\underline{A}\space\underline{BA}\space\underline{B}\)</span>，第一个<span class="math inline">\(A\)</span>与最后一个<span class="math inline">\(B\)</span>匹配，中间的<span class="math inline">\(AB\)</span>进行匹配，这就是对应<span class="math inline">\(n=1,m=1\)</span>的一种合法的字符串；</p><h4 id="分析">分析：</h4><p>  使用<span class="math inline">\(dp[i][j]\)</span>表示含有<span class="math inline">\(i\)</span>个<span class="math inline">\(A\)</span>和<span class="math inline">\(j\)</span>个<span class="math inline">\(B\)</span>的合法字符串的个数，目标为<span class="math inline">\(dp[n+m][n+m]\)</span>；</p><p>  首先，一个事实是，对于一个合法的含<span class="math inline">\(n\)</span>个<span class="math inline">\(AB\)</span>含<span class="math inline">\(m\)</span>个<span class="math inline">\(BA\)</span>的串，考虑它的前<span class="math inline">\(n\)</span>个<span class="math inline">\(A\)</span>作为<span class="math inline">\(AB\)</span>的<span class="math inline">\(A\)</span>，考虑前<span class="math inline">\(m\)</span>个<span class="math inline">\(B\)</span>作为<span class="math inline">\(BA\)</span>的<span class="math inline">\(B\)</span>;</p><p>  然后，对于<span class="math inline">\(i、j\)</span>，考虑在当前位置插入<span class="math inline">\(A\)</span>，或者在当前位置插入<span class="math inline">\(B\)</span>，那么我们有转移方程： <span class="math display">\[dp[i][j]=dp[i-1][j]+dp[i][j-1]\]</span></p><p>  然而中间并非所有的状态都合法；比如对于<span class="math inline">\(n=1,m=1\)</span>的情况，<span class="math inline">\(AABB\)</span>是不可行的，它没有被添加到最后的结果中，原因在于，在状态转移的过程中，从<span class="math inline">\(A\)</span>到<span class="math inline">\(AA\)</span>的转移是不可行的；第一个<span class="math inline">\(A\)</span>用作<span class="math inline">\(AB\)</span>的A，而对于第二个<span class="math inline">\(A\)</span>来说，由于此时<span class="math inline">\(AB\)</span>的<span class="math inline">\(A\)</span>数量已经够了，它应该是<span class="math inline">\(BA\)</span>的<span class="math inline">\(A\)</span>，所以它前面必须有<span class="math inline">\(B\)</span>，那么<span class="math inline">\(AA\)</span>显然是不可行的；</p><p>  如果在之前情况基础上，在最后位置插入<span class="math inline">\(A\)</span>，那么<span class="math inline">\(B\)</span>的数量<span class="math inline">\(j\)</span>必须不小于，<span class="math inline">\(A\)</span>的数量<span class="math inline">\(i\)</span>减去组成<span class="math inline">\(n\)</span>个<span class="math inline">\(AB\)</span>的<span class="math inline">\(A\)</span>的数量，即<span class="math inline">\(i-n&lt;=j\)</span>，如果插入<span class="math inline">\(B\)</span>，也同理；</p><a id="more"></a><h4 id="代码">代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">ll p=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n+m;j++)dp[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n+m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;=j+n)&#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j]=(dp[i+<span class="number">1</span>][j]+dp[i][j])%p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j+<span class="number">1</span>&lt;=i+m)&#123;</span><br><span class="line">                    dp[i][j+<span class="number">1</span>]=(dp[i][j+<span class="number">1</span>]+dp[i][j])%p;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dp[n+m][n+m]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;e.-abba&quot;&gt;E. ABBA&lt;/h3&gt;
&lt;h4 id=&quot;题意&quot;&gt;题意：&lt;/h4&gt;
&lt;p&gt;  你拥有一个长度为&lt;span class=&quot;math inline&quot;&gt;\(2*(n+m)\)&lt;/span&gt;的字符串，它含有&lt;span class=&quot;math inline&quot;&gt;\(n+m\)&lt;/span&gt;个&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;，以及&lt;span class=&quot;math inline&quot;&gt;\(n+m\)&lt;/span&gt;个&lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;，你把个字符串给分解，最后可以得到&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个子序列&lt;span class=&quot;math inline&quot;&gt;\(AB\)&lt;/span&gt;与&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;个子序列&lt;span class=&quot;math inline&quot;&gt;\(BA\)&lt;/span&gt;，问这个字符串有多少种，最终结果对（&lt;span class=&quot;math inline&quot;&gt;\(10^9+7\)&lt;/span&gt;）取余；比如&lt;span class=&quot;math inline&quot;&gt;\(\underline{A}\space\underline{BA}\space\underline{B}\)&lt;/span&gt;，第一个&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;与最后一个&lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;匹配，中间的&lt;span class=&quot;math inline&quot;&gt;\(AB\)&lt;/span&gt;进行匹配，这就是对应&lt;span class=&quot;math inline&quot;&gt;\(n=1,m=1\)&lt;/span&gt;的一种合法的字符串；&lt;/p&gt;
&lt;h4 id=&quot;分析&quot;&gt;分析：&lt;/h4&gt;
&lt;p&gt;  使用&lt;span class=&quot;math inline&quot;&gt;\(dp[i][j]\)&lt;/span&gt;表示含有&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;个&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt;个&lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;的合法字符串的个数，目标为&lt;span class=&quot;math inline&quot;&gt;\(dp[n+m][n+m]\)&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;  首先，一个事实是，对于一个合法的含&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个&lt;span class=&quot;math inline&quot;&gt;\(AB\)&lt;/span&gt;含&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;个&lt;span class=&quot;math inline&quot;&gt;\(BA\)&lt;/span&gt;的串，考虑它的前&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;作为&lt;span class=&quot;math inline&quot;&gt;\(AB\)&lt;/span&gt;的&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;，考虑前&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;个&lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;作为&lt;span class=&quot;math inline&quot;&gt;\(BA\)&lt;/span&gt;的&lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;;&lt;/p&gt;
&lt;p&gt;  然后，对于&lt;span class=&quot;math inline&quot;&gt;\(i、j\)&lt;/span&gt;，考虑在当前位置插入&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;，或者在当前位置插入&lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;，那么我们有转移方程： &lt;span class=&quot;math display&quot;&gt;\[dp[i][j]=dp[i-1][j]+dp[i][j-1]\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  然而中间并非所有的状态都合法；比如对于&lt;span class=&quot;math inline&quot;&gt;\(n=1,m=1\)&lt;/span&gt;的情况，&lt;span class=&quot;math inline&quot;&gt;\(AABB\)&lt;/span&gt;是不可行的，它没有被添加到最后的结果中，原因在于，在状态转移的过程中，从&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;到&lt;span class=&quot;math inline&quot;&gt;\(AA\)&lt;/span&gt;的转移是不可行的；第一个&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;用作&lt;span class=&quot;math inline&quot;&gt;\(AB\)&lt;/span&gt;的A，而对于第二个&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;来说，由于此时&lt;span class=&quot;math inline&quot;&gt;\(AB\)&lt;/span&gt;的&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;数量已经够了，它应该是&lt;span class=&quot;math inline&quot;&gt;\(BA\)&lt;/span&gt;的&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;，所以它前面必须有&lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;，那么&lt;span class=&quot;math inline&quot;&gt;\(AA\)&lt;/span&gt;显然是不可行的；&lt;/p&gt;
&lt;p&gt;  如果在之前情况基础上，在最后位置插入&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;，那么&lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;的数量&lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt;必须不小于，&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;的数量&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;减去组成&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个&lt;span class=&quot;math inline&quot;&gt;\(AB\)&lt;/span&gt;的&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;的数量，即&lt;span class=&quot;math inline&quot;&gt;\(i-n&amp;lt;=j\)&lt;/span&gt;，如果插入&lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;，也同理；&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://yuggu.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https://yuggu.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>DES(数据加密标准)</title>
    <link href="https://yuggu.github.io/2019/10/08/DES-%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86/"/>
    <id>https://yuggu.github.io/2019/10/08/DES-数据加密标准/</id>
    <published>2019-10-08T03:15:23.000Z</published>
    <updated>2019-10-08T03:24:46.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="des-数据加密标准">DES( 数据加密标准)</h2><h3 id="des">DES</h3><p>  <span class="math inline">\(\text{DES}\)</span>是一种数据加密标准，是一种对称加密算法，<span class="math inline">\(\text{DES}\)</span>算法的入口参数有三个：<span class="math inline">\(\text{Key、Date、Mode}\)</span>。其中<span class="math inline">\(\text{Key}\)</span>为8个字节共64位，是<span class="math inline">\(\text{DES}\)</span>算法的工作密钥；<span class="math inline">\(\text{Date}\)</span>也为8个字节64位，是要被加密或解密的数据；<span class="math inline">\(\text{Mode}\)</span>为<span class="math inline">\(\text{DES}\)</span>的工作方式，有两种：加密或解密。</p><p>  <span class="math inline">\(\text{DES}\)</span>算法是这样工作的：若<span class="math inline">\(\text{Mode}\)</span>为加密，则用<span class="math inline">\(\text{Key}\)</span>去把数据<span class="math inline">\(\text{Date}\)</span>进行加密，生成<span class="math inline">\(\text{Date}\)</span>的密码形式（64位）作为<span class="math inline">\(\text{DES}的输出结果；若\)</span>为解密，则用<span class="math inline">\(\text{Key}\)</span>去把密码形式的数据<span class="math inline">\(\text{Data}\)</span>解密，还原为<span class="math inline">\(\text{Date}\)</span>的明码形式（64位）作为<span class="math inline">\(\text{DES}\)</span>的输出结果。在通信网络的两端，双方约定一致的<span class="math inline">\(\text{Key}\)</span>，在通信的源点用<span class="math inline">\(\text{Key}\)</span>对核心数据进行<span class="math inline">\(\text{DES}\)</span>加密，然后以密码形式在公共通信网（如电话网）中传输到通信网络的终点，数据到达目的地后，用同样的<span class="math inline">\(\text{Key}\)</span>对密码数据进行解密，便再现了明码形式的核心数据。这样，便保证了核心数据（如<span class="math inline">\(\text{PIN、MAC}\)</span>等）在公共通信网中传输的安全性和可靠性。</p><a id="more"></a><h3 id="des加密算法">DES加密算法</h3><p>  下面的图表示了<span class="math inline">\(\text{DES}\)</span>加密的整个机制，对于任意加密方案，总有两个输入：明文和密钥。<span class="math inline">\(\text{DES}\)</span>的明文长为64位，密钥长为56位（实际上是64位，其余8位可以奇偶校验或随意设置）。</p><p>  由图左部分可知，明文的处理经过了三个阶段，首先64位的明文经过初始置换IP而重新排列。然后进行16轮相同函数的作用，每轮作用都有置换和替换，最后一轮迭代的输出有64位；图的右半部分给出了使用56位密钥的过程，首先，密钥经过一个置换，在经过循环左移和一个置换就得到了各轮的子密钥<span class="math inline">\(K_i\)</span>，每轮的置换函数都一样，但是由于密钥的循环左移，使得每轮的子密钥互不相同。</p><p><img src="/images/des_2.png" width="550px"></p><h4 id="获取子密钥k_i">获取子密钥<span class="math inline">\(K_i\)</span></h4><p>  <span class="math inline">\(\text{DES}\)</span>的初始密钥<span class="math inline">\(\text{K}\)</span>为64位，按8行8列从左往右从上往下，其中每行第8位用于奇偶校验（即<span class="math inline">\(K\)</span>的第8、16、24、32、40、48、56、64共8个校验），因此初始密钥<span class="math inline">\(K\)</span>实际可用56位，之后通过<span class="math inline">\(\text{PC-1}\)</span>置换函数进行置换，<span class="math inline">\(\text{PC-1}\)</span>函数置换表如图，即将初始密钥<span class="math inline">\(\text{K}\)</span>的第57位（这里的位数，将校验位也计算在内）放在第1位，第49位放在第2位，依次类推；</p><p><img src="/images/des_3.png" width="450px"></p><p>  经过<span class="math inline">\(\text{PC-1}\)</span>置换，得到的置换输出是56位的，将它的前28位作为<span class="math inline">\(C_0\)</span>，后28位作为<span class="math inline">\(D_0\)</span>，之后<span class="math inline">\(C_0、D_0\)</span>分别<strong>循环左移</strong>1位得到<span class="math inline">\(C_1、D_1\)</span>，然后将两部分合成56位，在将这个56位的结果通过<span class="math inline">\(\text{PC-2}\)</span>函数置换，就得到了48位的子密钥<span class="math inline">\(K_1\)</span>，<span class="math inline">\(\text{PC-2}\)</span>函数置换表如下；</p><p><img src="/images/des_4.png" width="350px"></p><p>  对于上面所说的循环左移，是分别针对<span class="math inline">\(C_0\)</span>和<span class="math inline">\(D_0\)</span>所说的，它的意思是，对于<span class="math inline">\(C_0\)</span>把它的第2~28位整体左移1位，而第1位就就移动到空闲下来的第28位上；另外这里不一定是移动1位，也可能是移动2位，要按规定来，下面给出具体移动位数的规定。</p><p><img src="/images/des_5.png" width="550px"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;des-数据加密标准&quot;&gt;DES( 数据加密标准)&lt;/h2&gt;
&lt;h3 id=&quot;des&quot;&gt;DES&lt;/h3&gt;
&lt;p&gt;  &lt;span class=&quot;math inline&quot;&gt;\(\text{DES}\)&lt;/span&gt;是一种数据加密标准，是一种对称加密算法，&lt;span class=&quot;math inline&quot;&gt;\(\text{DES}\)&lt;/span&gt;算法的入口参数有三个：&lt;span class=&quot;math inline&quot;&gt;\(\text{Key、Date、Mode}\)&lt;/span&gt;。其中&lt;span class=&quot;math inline&quot;&gt;\(\text{Key}\)&lt;/span&gt;为8个字节共64位，是&lt;span class=&quot;math inline&quot;&gt;\(\text{DES}\)&lt;/span&gt;算法的工作密钥；&lt;span class=&quot;math inline&quot;&gt;\(\text{Date}\)&lt;/span&gt;也为8个字节64位，是要被加密或解密的数据；&lt;span class=&quot;math inline&quot;&gt;\(\text{Mode}\)&lt;/span&gt;为&lt;span class=&quot;math inline&quot;&gt;\(\text{DES}\)&lt;/span&gt;的工作方式，有两种：加密或解密。&lt;/p&gt;
&lt;p&gt;  &lt;span class=&quot;math inline&quot;&gt;\(\text{DES}\)&lt;/span&gt;算法是这样工作的：若&lt;span class=&quot;math inline&quot;&gt;\(\text{Mode}\)&lt;/span&gt;为加密，则用&lt;span class=&quot;math inline&quot;&gt;\(\text{Key}\)&lt;/span&gt;去把数据&lt;span class=&quot;math inline&quot;&gt;\(\text{Date}\)&lt;/span&gt;进行加密，生成&lt;span class=&quot;math inline&quot;&gt;\(\text{Date}\)&lt;/span&gt;的密码形式（64位）作为&lt;span class=&quot;math inline&quot;&gt;\(\text{DES}的输出结果；若\)&lt;/span&gt;为解密，则用&lt;span class=&quot;math inline&quot;&gt;\(\text{Key}\)&lt;/span&gt;去把密码形式的数据&lt;span class=&quot;math inline&quot;&gt;\(\text{Data}\)&lt;/span&gt;解密，还原为&lt;span class=&quot;math inline&quot;&gt;\(\text{Date}\)&lt;/span&gt;的明码形式（64位）作为&lt;span class=&quot;math inline&quot;&gt;\(\text{DES}\)&lt;/span&gt;的输出结果。在通信网络的两端，双方约定一致的&lt;span class=&quot;math inline&quot;&gt;\(\text{Key}\)&lt;/span&gt;，在通信的源点用&lt;span class=&quot;math inline&quot;&gt;\(\text{Key}\)&lt;/span&gt;对核心数据进行&lt;span class=&quot;math inline&quot;&gt;\(\text{DES}\)&lt;/span&gt;加密，然后以密码形式在公共通信网（如电话网）中传输到通信网络的终点，数据到达目的地后，用同样的&lt;span class=&quot;math inline&quot;&gt;\(\text{Key}\)&lt;/span&gt;对密码数据进行解密，便再现了明码形式的核心数据。这样，便保证了核心数据（如&lt;span class=&quot;math inline&quot;&gt;\(\text{PIN、MAC}\)&lt;/span&gt;等）在公共通信网中传输的安全性和可靠性。&lt;/p&gt;
    
    </summary>
    
      <category term="信息安全" scheme="https://yuggu.github.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="DES" scheme="https://yuggu.github.io/tags/DES/"/>
    
      <category term="数据加密" scheme="https://yuggu.github.io/tags/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>[POJ - 2288] Islands and Bridges</title>
    <link href="https://yuggu.github.io/2019/10/03/POJ-2288-Islands-and-Bridges/"/>
    <id>https://yuggu.github.io/2019/10/03/POJ-2288-Islands-and-Bridges/</id>
    <published>2019-10-03T08:47:04.000Z</published>
    <updated>2019-10-03T08:52:08.012Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链接">链接</h3><p><a href="http://poj.org/problem?id=2288" target="_blank" rel="noopener"><span class="math inline">\(\text{POJ - 2288 Islands and Bridges}\)</span></a></p><h3 id="题意">题意</h3><p>  这里有<span class="math inline">\(n\)</span>个城市，定义最好的三角哈密顿路径为<span class="math inline">\(value\)</span>值最大的哈密顿路径，<span class="math inline">\(value\)</span>产生于三部分，如果经过某个城市<span class="math inline">\(x\)</span>那么这个城市将贡献<span class="math inline">\(value_x\)</span>，如果经过连续两个城市<span class="math inline">\(x、y\)</span>，那么将贡献<span class="math inline">\(value_x*value_y\)</span>，如果经过连续三个城市<span class="math inline">\(x、y、z\)</span>，那么将贡献<span class="math inline">\(value_x*value_y*value_z\)</span>，这里说的连续不是说城市编号连续，需要你求出这个图的三角哈密顿路径的长度，以及它的个数；</p><p>  数据范围：<span class="math inline">\(1\leq n\leq 13,value_i\leq 100\)</span>.</p><a id="more"></a><h3 id="分析">分析</h3><p>  三角的意思是，<span class="math inline">\(i\)</span>可以到<span class="math inline">\(j\)</span>，<span class="math inline">\(j\)</span>可以到<span class="math inline">\(k\)</span>，<span class="math inline">\(k\)</span>可以到<span class="math inline">\(i\)</span>，由于我们需要求连续三个城市的贡献，所以我们需要开一个三维的数组<span class="math inline">\(dp[s][i][j]\)</span>，其中<span class="math inline">\(s\)</span>表示到达<span class="math inline">\(i\)</span>的当前的状态，<span class="math inline">\(i\)</span>的前一个经过的点是<span class="math inline">\(j\)</span>，同样的还需要一个数组<span class="math inline">\(num[s][i][j]\)</span>来记录哈密顿路径的个数；</p><p>  首先初始化<span class="math inline">\(num\)</span>为0，及<span class="math inline">\(dp[(1&lt;&lt;i)|(1&lt;&lt;j)][i][j]=value_i+value_j+value_i*value_j\)</span>，<span class="math inline">\(i、j\)</span>为任意两个城市，<span class="math inline">\(i、j\)</span>不相等；</p><p>  枚举状态s，以及三个点<span class="math inline">\(i、j、k\)</span>，考虑从上一个点<span class="math inline">\(j\)</span>转移到当前点<span class="math inline">\(i\)</span>，而<span class="math inline">\(j\)</span>的上一个点为<span class="math inline">\(k\)</span>，考虑从上一个状态转移过来，那么假设当前状态为<span class="math inline">\(s\)</span>，则有<span class="math inline">\(dp[s][i][j]=\max dp[s\space xor\space (1&lt;&lt;i)][j][k]\)</span>，主要判断<span class="math inline">\(i、j、k\)</span>是否可以组成三角形，若可以还需要把<span class="math inline">\(dp[s][i][j]\)</span>加上<span class="math inline">\(value_x*value_y*value_z\)</span>，关于数量的计算，看<span class="math inline">\(dp[s][i][j]\)</span>是否能够通过之前的状态更新，若能更新，就令当前数量等于上一个转移过来的状态的数量，若二者相等，就把之前的状态的数量加到当前的状态的数量上，具体见代码；</p><p>  需要注意的是，在转移的过程中还需要判断之前的那个状态是否是有效的状态，即存在这样的情况，现在的状态是s，之前的状态<span class="math inline">\(p\)</span>，虽然它的<span class="math inline">\(j、k\)</span>位都是1，<span class="math inline">\(i\)</span>位是1，但是这个状态<span class="math inline">\(p\)</span>并不能通过<span class="math inline">\(p\)</span>之前的任意一个可行状态转移过来，所以状态<span class="math inline">\(p\)</span>的值还是初始的时候我们初始化的值；对于这种情况我们就需要判断<span class="math inline">\(dp[s^(1&lt;&lt;i)][j][k]\)</span>的状态；自己写的时候，第一次没注意<span class="math inline">\(int\)</span>，之后改成<span class="math inline">\(long\space long\)</span>，还是<span class="math inline">\(wa\)</span>，然后不知哪错，疯狂交，疯狂<span class="math inline">\(wa\)</span>，看了一个小时才找到问题。<strong>以后要注意，这里出现这样的原因，应该是图的原因，给出的图不一定是个完全图，某些边是不连通的。</strong></p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300005</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'-'</span>)</span><br><span class="line">            f = <span class="number">-1</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (c &gt;= <span class="string">'0'</span>&amp;&amp;c &lt;= <span class="string">'9'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll q, n, m, dp[<span class="number">1</span> &lt;&lt; <span class="number">14</span>][<span class="number">15</span>][<span class="number">15</span>], num[<span class="number">1</span> &lt;&lt; <span class="number">14</span>][<span class="number">15</span>][<span class="number">15</span>], val[<span class="number">15</span>], e[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("test.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("test.out", "w", stdout);</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; val[i];</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">memset</span>(e, <span class="number">0</span>, <span class="keyword">sizeof</span>(e));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            a--, b--;</span><br><span class="line">            e[a][b] = e[b][a] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; val[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j || !e[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                dp[(<span class="number">1</span> &lt;&lt; i) | (<span class="number">1</span> &lt;&lt; j)][i][j] = val[i] + val[j] + val[i] * val[j];</span><br><span class="line">                num[(<span class="number">1</span> &lt;&lt; i) | (<span class="number">1</span> &lt;&lt; j)][i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">1</span> &lt;&lt; n; s++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                <span class="keyword">if</span> ((s &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!e[i][j] || !((s &gt;&gt; j) &amp; <span class="number">1</span>) || i == j) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!((s &gt;&gt; k) &amp; <span class="number">1</span>) || !e[j][k]||k == i || j == k) <span class="keyword">continue</span>;</span><br><span class="line">                            <span class="keyword">if</span> (!dp[s ^ (<span class="number">1</span> &lt;&lt; i)][j][k]) <span class="keyword">continue</span>;</span><br><span class="line">                            ll temp = dp[s ^ (<span class="number">1</span> &lt;&lt; i)][j][k] + val[i] + val[i] * val[j];</span><br><span class="line">                            <span class="keyword">if</span> (e[i][k]) temp += val[i] * val[j] * val[k];</span><br><span class="line">                            <span class="keyword">if</span> (temp &gt; dp[s][i][j]) &#123;</span><br><span class="line">                                dp[s][i][j] = temp;</span><br><span class="line">                                num[s][i][j] =  num[s ^ (<span class="number">1</span> &lt;&lt; i)][j][k];</span><br><span class="line">                            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp == dp[s][i][j]) &#123;</span><br><span class="line">                                num[s][i][j] +=  num[s ^ (<span class="number">1</span> &lt;&lt; i)][j][k];                                </span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>,cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j || !e[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (ans &lt; dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][i][j]) &#123;</span><br><span class="line">                    ans = dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][i][j];</span><br><span class="line">                    cnt = num[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][i][j];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ans == dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][i][j])&#123;</span><br><span class="line">                    cnt += num[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">" "</span> &lt;&lt; cnt / <span class="number">2</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;链接&quot;&gt;链接&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=2288&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\(\text{POJ - 2288 Islands and Bridges}\)&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题意&quot;&gt;题意&lt;/h3&gt;
&lt;p&gt;  这里有&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个城市，定义最好的三角哈密顿路径为&lt;span class=&quot;math inline&quot;&gt;\(value\)&lt;/span&gt;值最大的哈密顿路径，&lt;span class=&quot;math inline&quot;&gt;\(value\)&lt;/span&gt;产生于三部分，如果经过某个城市&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;那么这个城市将贡献&lt;span class=&quot;math inline&quot;&gt;\(value_x\)&lt;/span&gt;，如果经过连续两个城市&lt;span class=&quot;math inline&quot;&gt;\(x、y\)&lt;/span&gt;，那么将贡献&lt;span class=&quot;math inline&quot;&gt;\(value_x*value_y\)&lt;/span&gt;，如果经过连续三个城市&lt;span class=&quot;math inline&quot;&gt;\(x、y、z\)&lt;/span&gt;，那么将贡献&lt;span class=&quot;math inline&quot;&gt;\(value_x*value_y*value_z\)&lt;/span&gt;，这里说的连续不是说城市编号连续，需要你求出这个图的三角哈密顿路径的长度，以及它的个数；&lt;/p&gt;
&lt;p&gt;  数据范围：&lt;span class=&quot;math inline&quot;&gt;\(1\leq n\leq 13,value_i\leq 100\)&lt;/span&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="dp" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/dp/"/>
    
      <category term="状压dp" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/dp/%E7%8A%B6%E5%8E%8Bdp/"/>
    
    
      <category term="算法" scheme="https://yuggu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="状压dp" scheme="https://yuggu.github.io/tags/%E7%8A%B6%E5%8E%8Bdp/"/>
    
  </entry>
  
  <entry>
    <title>[HDU - 3001] Travelling</title>
    <link href="https://yuggu.github.io/2019/10/03/HDU-3001-Travelling/"/>
    <id>https://yuggu.github.io/2019/10/03/HDU-3001-Travelling/</id>
    <published>2019-10-03T05:17:04.000Z</published>
    <updated>2019-10-03T05:20:49.011Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链接">链接</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3001" target="_blank" rel="noopener"><span class="math inline">\(\text{HDU - 3001 Travelling}\)</span></a></p><h3 id="题意">题意</h3><p>  某一天你有个旅游的计划，这里有<span class="math inline">\(n\)</span>个城市，你想要访问完<span class="math inline">\(n\)</span>个城市，开始的时候你可以从任何城市出发，你已经知道了一个二维矩阵<span class="math inline">\(a[i][j]\)</span>，表示城市<span class="math inline">\(i\)</span>与城市<span class="math inline">\(j\)</span>之间互相抵达需要的花费，现在需要计算出访问完<span class="math inline">\(n\)</span>个城市所需要的最小花费，每个城市最多被允许访问两次。</p><p>  数据范围：<span class="math inline">\(1\leq n\leq 10\)</span>.</p><a id="more"></a><h3 id="分析">分析</h3><p>  首先如果每个点只被允许访问一次，并且指定起点，那么显然是一个最短<span class="math inline">\(\text{Hamilton}\)</span>路径问题；</p><p>  第一次读题，我以为是个不指定起点的最短哈密顿路径问题，然后我就<span class="math inline">\(O(n^{2})\)</span>枚举起点终点，然后套个<span class="math inline">\(O(2^n*n^{2})\)</span>的状压<span class="math inline">\(dp\)</span>，就是<span class="math inline">\(O(n^4*2^n)\)</span>，后来看题解发现读错题了；对于不指定起点终点的情况来说，可以不用这么做，在指定起点为0的最短哈密顿路径中，我们初始化<span class="math inline">\(dp[1][0]=0\)</span>，其他为<span class="math inline">\(\infty\)</span>，那么不指定起点它可能开始的时候在任意位置，我们就初始化，在任意城市为起点的状态为0，即<span class="math inline">\(dp[1&lt;&lt;pos][pos]_{pos\in [0,n)}=0\)</span>，最后目标是<span class="math inline">\(\min_{end\in [0,n)}dp[(1&lt;&lt;n)-1][end]\)</span>；</p><p>  那么对于这一题来说，其实将最短哈密顿路径的<code>每个点只允许被经过一次</code>，变成了<code>每个点至少经过一次，最多经过2次</code>，那么原来使用2进制，0表示没经过，1表示经过；那么现在使用3进制，0表示没经过，1表示经过一次，2表示经过2次；与2进制不同，3进制不能通过简单位运算取出某一位上的数、对某一位进行取反等一些操作，所以我们需要进行一些预处理，预处理状态<span class="math inline">\(s\)</span>的第<span class="math inline">\(k\)</span>位是什么，还需要用到<code>仅走过城市k一次</code>所表示的状态，还需要处理下这个；</p><p>  <strong>注意代码中的<span class="math inline">\(status[x]\)</span>，在三进制下是怎么表示的，这里不是说它的意义。</strong></p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300005</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'-'</span>)</span><br><span class="line">            f = <span class="number">-1</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (c &gt;= <span class="string">'0'</span>&amp;&amp;c &lt;= <span class="string">'9'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cost[<span class="number">11</span>][<span class="number">11</span>], dp[<span class="number">60005</span>][<span class="number">11</span>], status[<span class="number">11</span>], t[<span class="number">60005</span>][<span class="number">11</span>];</span><br><span class="line"><span class="comment">//预处理，状态s的第i位是t[s][i]，status[i]为，三进制下，n个城市中，只有第i个城市访被问一次所代表的状态</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    status[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        status[i] = status[i - <span class="number">1</span>] * <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= status[<span class="number">10</span>]; s++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">            t[s][k] = num % <span class="number">3</span>;</span><br><span class="line">            num /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断x的每一位是不是都大于1,说明任意一个城市都至少访问过一次</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">is_ok</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(x % <span class="number">3</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        x /= <span class="number">3</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("test.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("test.out", "w", stdout);</span></span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cost, inf, <span class="keyword">sizeof</span>(cost));</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            a--, b--;</span><br><span class="line">            cost[a][b] = cost[b][a] = min(c, cost[b][a]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, inf, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[status[i]][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; status[n]; s++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                <span class="keyword">if</span> (t[s][i])</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span> (t[s][j]) &#123;</span><br><span class="line">                            dp[s][i] = min(dp[s][i], dp[s - status[i]][j] + cost[j][i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = status[n - <span class="number">1</span>]; i &lt; status[n]; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (is_ok(i)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                    ans = min(ans, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt;= inf) <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;链接&quot;&gt;链接&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=3001&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\(\text{HDU - 3001 Travelling}\)&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题意&quot;&gt;题意&lt;/h3&gt;
&lt;p&gt;  某一天你有个旅游的计划，这里有&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个城市，你想要访问完&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个城市，开始的时候你可以从任何城市出发，你已经知道了一个二维矩阵&lt;span class=&quot;math inline&quot;&gt;\(a[i][j]\)&lt;/span&gt;，表示城市&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;与城市&lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt;之间互相抵达需要的花费，现在需要计算出访问完&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个城市所需要的最小花费，每个城市最多被允许访问两次。&lt;/p&gt;
&lt;p&gt;  数据范围：&lt;span class=&quot;math inline&quot;&gt;\(1\leq n\leq 10\)&lt;/span&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="dp" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/dp/"/>
    
      <category term="状压dp" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/dp/%E7%8A%B6%E5%8E%8Bdp/"/>
    
    
      <category term="算法" scheme="https://yuggu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="状压dp" scheme="https://yuggu.github.io/tags/%E7%8A%B6%E5%8E%8Bdp/"/>
    
  </entry>
  
  <entry>
    <title>[ABC142] E.Get Everything</title>
    <link href="https://yuggu.github.io/2019/09/29/ABC142-E.Get-Everything/"/>
    <id>https://yuggu.github.io/2019/09/29/ABC142-E.Get-Everything/</id>
    <published>2019-09-29T11:45:14.000Z</published>
    <updated>2019-10-22T13:37:41.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链接">链接</h3><p><a href="https://atcoder.jp/contests/abc142/tasks/abc142_e" target="_blank" rel="noopener"><span class="math inline">\(\text{ABC142 E - Get Everything}\)</span></a></p><h3 id="题意">题意</h3><p>  这里有<span class="math inline">\(n\)</span>个锁着的箱子，你需要购买一些钥匙来打开这<span class="math inline">\(n\)</span>个箱子，这里有<span class="math inline">\(m\)</span>钥匙，第<span class="math inline">\(i\)</span>个钥匙的花费为<span class="math inline">\(a_i\)</span>，它能打开<span class="math inline">\(n\)</span>个箱子中的<span class="math inline">\(b_i\)</span>个，分别是<span class="math inline">\(c_{i1}、c_{i2}\dots c_{i{b_{n}}}\)</span>，现在你需要从这<span class="math inline">\(m\)</span>个钥匙中选出若干个钥匙来打开这<span class="math inline">\(n\)</span>个箱子，使得花费最小。</p><p>  输入格式：第一行<span class="math inline">\(n、m\)</span>，之后<span class="math inline">\(2*m\)</span>行，每连续两行的第一行，<span class="math inline">\(a_i、b_i\)</span>，之后一行<span class="math inline">\(b_i\)</span>个数，代表这个钥匙可以打开的箱子的编号。</p><p>  输出格式：输出一行最小花费.</p><p>  数据范围：<span class="math inline">\(1\leq n\leq 12,1\leq m\leq 10^3,1\leq a_{i}\leq 10^5,1\leq b_i\leq n,1\leq c_{i1}&lt;c_{i2}&lt;\dots &lt;c_{ib_{i}}\leq n\)</span>.</p><a id="more"></a><h3 id="分析">分析</h3><p>  第一印象这是个<span class="math inline">\(dp\)</span>，注意到<span class="math inline">\(n\)</span>最大为<span class="math inline">\(12\)</span>，并结合题意可知，需要使用状压<span class="math inline">\(dp\)</span>；</p><p>  二进制压缩保存每个钥匙能开的那些宝箱的状态，<span class="math inline">\(1\)</span>表示箱子可以被开，<span class="math inline">\(0\)</span>表示箱子不能被打开，<span class="math inline">\(f[i]\)</span>表示打开箱子的状态为<span class="math inline">\(i\)</span>时，所需要的最小花费，枚举箱子的状态<span class="math inline">\(i\)</span>和第<span class="math inline">\(j\)</span>枚钥匙，进行状态转移：</p><p><span class="math display">\[f[i|state[j]]=\min(f[i|state[j]],f[i]+cost[j])\]</span></p><p>  初始状态<span class="math inline">\(f[0]\)</span>为<span class="math inline">\(0\)</span>，其他为<span class="math inline">\(\infty\)</span>，目标为<span class="math inline">\(f[(1&lt;&lt;n)-1]\)</span>.</p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> cost, state;</span><br><span class="line">&#125;p[<span class="number">1005</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n, m, f[<span class="number">1</span> &lt;&lt; <span class="number">14</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; p[i].cost;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, t, x;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">      <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">          sum += (<span class="number">1</span> &lt;&lt; (x - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    p[i].state = sum;</span><br><span class="line">      f[sum] = p[i].cost;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        f[i | p[j].state] = min(f[i | p[j].state], f[i] + p[j].cost);</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="keyword">if</span> (f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>] == <span class="number">0x3f3f3f3f</span>)<span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;链接&quot;&gt;链接&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://atcoder.jp/contests/abc142/tasks/abc142_e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\(\text{ABC142 E - Get Everything}\)&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题意&quot;&gt;题意&lt;/h3&gt;
&lt;p&gt;  这里有&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个锁着的箱子，你需要购买一些钥匙来打开这&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个箱子，这里有&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;钥匙，第&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;个钥匙的花费为&lt;span class=&quot;math inline&quot;&gt;\(a_i\)&lt;/span&gt;，它能打开&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个箱子中的&lt;span class=&quot;math inline&quot;&gt;\(b_i\)&lt;/span&gt;个，分别是&lt;span class=&quot;math inline&quot;&gt;\(c_{i1}、c_{i2}\dots c_{i{b_{n}}}\)&lt;/span&gt;，现在你需要从这&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;个钥匙中选出若干个钥匙来打开这&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个箱子，使得花费最小。&lt;/p&gt;
&lt;p&gt;  输入格式：第一行&lt;span class=&quot;math inline&quot;&gt;\(n、m\)&lt;/span&gt;，之后&lt;span class=&quot;math inline&quot;&gt;\(2*m\)&lt;/span&gt;行，每连续两行的第一行，&lt;span class=&quot;math inline&quot;&gt;\(a_i、b_i\)&lt;/span&gt;，之后一行&lt;span class=&quot;math inline&quot;&gt;\(b_i\)&lt;/span&gt;个数，代表这个钥匙可以打开的箱子的编号。&lt;/p&gt;
&lt;p&gt;  输出格式：输出一行最小花费.&lt;/p&gt;
&lt;p&gt;  数据范围：&lt;span class=&quot;math inline&quot;&gt;\(1\leq n\leq 12,1\leq m\leq 10^3,1\leq a_{i}\leq 10^5,1\leq b_i\leq n,1\leq c_{i1}&amp;lt;c_{i2}&amp;lt;\dots &amp;lt;c_{ib_{i}}\leq n\)&lt;/span&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="dp" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/dp/"/>
    
      <category term="状压dp" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/dp/%E7%8A%B6%E5%8E%8Bdp/"/>
    
    
      <category term="算法" scheme="https://yuggu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="状压dp" scheme="https://yuggu.github.io/tags/%E7%8A%B6%E5%8E%8Bdp/"/>
    
  </entry>
  
  <entry>
    <title>[ABC140] E.Second Sum</title>
    <link href="https://yuggu.github.io/2019/09/29/ABC140-E.Second-Sum/"/>
    <id>https://yuggu.github.io/2019/09/29/ABC140-E.Second-Sum/</id>
    <published>2019-09-29T10:40:54.000Z</published>
    <updated>2019-10-22T13:37:47.711Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链接">链接</h3><p><a href="https://atcoder.jp/contests/abc140/tasks/abc140_e" target="_blank" rel="noopener"><span class="math inline">\(\text{ABC140 E - Second Sum}\)</span></a></p><h3 id="题意">题意</h3><p>  给你一个长度为<span class="math inline">\(n\)</span>的序列<span class="math inline">\(P\)</span>，对于一个区间<span class="math inline">\((L,R)\)</span>，<span class="math inline">\(X_{L}\)</span>为该区间第二大的数，求出<span class="math inline">\(\displaystyle\sum_{L=1}^{N-1}\sum_{R-L+1}^{N}X_{L,R}\)</span>.</p><p>  即让你求出对于每一个<span class="math inline">\(a[i]\)</span>，<span class="math inline">\(a[i]\)</span>作为第二大值的区间个数<span class="math inline">\(cnt\)</span>乘以<span class="math inline">\(a[i]\)</span>，求出这个结果。</p><p>  输入格式：第一行输入<span class="math inline">\(N\)</span>，第二行输入一个长度为<span class="math inline">\(n\)</span>的序列<span class="math inline">\(P\)</span>.</p><p>  输出格式：输出一行.</p><p>  数据范围：<span class="math inline">\(2\leq n\leq 10^{5},1\leq P_{I}\leq n,P_{i}\neq P_{j}\)</span>.</p><a id="more"></a><h3 id="分析">分析</h3><p>  首先整个序列是<span class="math inline">\(1-n\)</span>的一个排列，首先考虑这样一种情况，对于<span class="math inline">\(a[i]\)</span>来说，<span class="math inline">\(a[x_1]、a[x_2]\)</span>分别是比<span class="math inline">\(a[i]\)</span>第一大、第二大的并且位于<span class="math inline">\(a[i]\)</span>的两个数，<span class="math inline">\(a[x_3]、a[x_4]\)</span>则是比<span class="math inline">\(a[i]\)</span>第一大、第二大位于<span class="math inline">\(a[i]\)</span>右边的两个数，那么则有<span class="math inline">\(a[i]\)</span>作为第二大的数对答案的贡献为：<span class="math inline">\(((x_2-x_1)*(x_3-i)+(x_4-x_3)*(i-x_2))*a[i]\)</span>。</p><p>  所以实际上我们只关心，比当前<span class="math inline">\(a[x]\)</span>大的数，以及它的下标；那么我们使用一个<span class="math inline">\(set\)</span>，将数列从大到小，将它们的下标插入<span class="math inline">\(set\)</span>里，对当前的<span class="math inline">\(a[i]\)</span>，在<span class="math inline">\(set\)</span>里对<span class="math inline">\(i\)</span>进行二分找<span class="math inline">\(x_1、x_2、x_3、x_4\)</span>，此时<span class="math inline">\(set\)</span>里的元素一定是比<span class="math inline">\(a[i]\)</span>大的，这样就能以上面的方式求出<span class="math inline">\(a[i]\)</span>对答案的贡献。</p><p>  注意考虑特殊的情况。</p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300005</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'-'</span>)</span><br><span class="line">            f = <span class="number">-1</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (c &gt;= <span class="string">'0'</span>&amp;&amp;c &lt;= <span class="string">'9'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N], p[N];</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator st;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    s.insert(<span class="number">0</span>), s.insert(<span class="number">0</span>);</span><br><span class="line">    s.insert(n + <span class="number">1</span>), s.insert(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        p[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        st r2 = s.upper_bound(p[i]), l2 = r2++;</span><br><span class="line">        st r1 = l2--, l1 = l2--;</span><br><span class="line">        ans += <span class="number">1l</span>l * (*l1 - *l2) * (*r1 - p[i]) * i;</span><br><span class="line">        ans += <span class="number">1l</span>l * (*r2 - *r1) * (p[i] - *l1) * i;</span><br><span class="line">        s.insert(p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;链接&quot;&gt;链接&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://atcoder.jp/contests/abc140/tasks/abc140_e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\(\text{ABC140 E - Second Sum}\)&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题意&quot;&gt;题意&lt;/h3&gt;
&lt;p&gt;  给你一个长度为&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;的序列&lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt;，对于一个区间&lt;span class=&quot;math inline&quot;&gt;\((L,R)\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(X_{L}\)&lt;/span&gt;为该区间第二大的数，求出&lt;span class=&quot;math inline&quot;&gt;\(\displaystyle\sum_{L=1}^{N-1}\sum_{R-L+1}^{N}X_{L,R}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;  即让你求出对于每一个&lt;span class=&quot;math inline&quot;&gt;\(a[i]\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(a[i]\)&lt;/span&gt;作为第二大值的区间个数&lt;span class=&quot;math inline&quot;&gt;\(cnt\)&lt;/span&gt;乘以&lt;span class=&quot;math inline&quot;&gt;\(a[i]\)&lt;/span&gt;，求出这个结果。&lt;/p&gt;
&lt;p&gt;  输入格式：第一行输入&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;，第二行输入一个长度为&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;的序列&lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;  输出格式：输出一行.&lt;/p&gt;
&lt;p&gt;  数据范围：&lt;span class=&quot;math inline&quot;&gt;\(2\leq n\leq 10^{5},1\leq P_{I}\leq n,P_{i}\neq P_{j}\)&lt;/span&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/"/>
    
    
      <category term="思维" scheme="https://yuggu.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="二分" scheme="https://yuggu.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>[POJ - 1185] 炮兵阵地</title>
    <link href="https://yuggu.github.io/2019/09/27/POJ-1185-%E7%82%AE%E5%85%B5%E9%98%B5%E5%9C%B0/"/>
    <id>https://yuggu.github.io/2019/09/27/POJ-1185-炮兵阵地/</id>
    <published>2019-09-27T12:16:45.000Z</published>
    <updated>2019-09-29T11:00:28.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链接">链接</h3><p><a href="http://poj.org/problem?id=1185" target="_blank" rel="noopener"><span class="math inline">\(\text{POJ - 1185 炮兵阵地}\)</span></a></p><h3 id="题意">题意</h3><p>  给你一个<span class="math inline">\(N\times M\)</span>的网格地图，这个地图上的每一格上如果是<code>H</code>则代表山地，若是<code>P</code>则代表平原，在平原上可以布置一只炮兵部队（山地上不能部署部队），一只炮兵的攻击范围如下。</p><p><img src="/images/POJ1185_1.jpg" width="300px"></p><p>  现在需要你在这张<span class="math inline">\(N\times M\)</span>的地图上部署部队，在避免误伤的前提下（即任意一支部队都不在其他部队的攻击范围之内），问你最多能布置多少只部队。</p><p>  输入格式：第一行输入<span class="math inline">\(N,M\)</span>，之后输入一个<span class="math inline">\(N\times M\)</span>的使用<code>H</code>和<code>P</code>表示的地图。</p><p>  输出格式：输出最多可以布置的部队的数量。</p><p>  数据范围：<span class="math inline">\(N\leq 100,M\leq 10\)</span> <a id="more"></a></p><h3 id="分析">分析</h3><p>  如果攻击范围为沿纵横各延伸1格，那么我们将第<span class="math inline">\(i\)</span>行作为阶段，每一行部队的布置情况作为状态，那么枚举两层（第<span class="math inline">\(i\)</span>和第<span class="math inline">\(i-1\)</span>行）的<strong>可行状态</strong>，进行转移即可，然而这里的攻击范围波及到了第<span class="math inline">\(i-2\)</span>行，所以我们还要考虑第<span class="math inline">\(i-2\)</span>行的状态。</p><p>  将放置部队的位置置为1，首先预处理一下所有的可行的状态（即相邻两个<span class="math inline">\(1\)</span>之间的距离不小于3），用<span class="math inline">\(f[i][j][k]\)</span>表示第<span class="math inline">\(i\)</span>行的状态为<span class="math inline">\(j\)</span>第<span class="math inline">\(i-1\)</span>行的状态为<span class="math inline">\(k\)</span>时，前<span class="math inline">\(i\)</span>行最多能放置多少个部队，考虑<span class="math inline">\(f[i-1][k][l]\)</span>向<span class="math inline">\(f[i][j][k]\)</span>转移，那么有：</p><p><span class="math display">\[f[i][j][k]=\max{f[i-1][k][l]}+sum(i)\]</span></p><p>  在满足状态<span class="math inline">\(j\)</span>不与状态<span class="math inline">\(k\)</span>和<span class="math inline">\(l\)</span>冲突的情况下，<span class="math inline">\(sum(i)\)</span>即是这种情况下的第<span class="math inline">\(i\)</span>行状态<span class="math inline">\(j\)</span>的<span class="math inline">\(1\)</span>的个数，还需要预处理一下地图的状态，保证每行地图的状态与每一行布置部队的状态不冲突（即只能在<code>P</code>位置布置部队），还要预处理一下每一行<span class="math inline">\(((1&lt;&lt;M)-1)\)</span>个状态中的可行的状态（即相邻两个<span class="math inline">\(1\)</span>之间的距离不小于<span class="math inline">\(3\)</span>的状态），<span class="math inline">\(M\)</span>为<span class="math inline">\(10\)</span>的时候最多有<span class="math inline">\(60\)</span>个，存储信息的<span class="math inline">\(f\)</span>数组的第二维第三维最大开<span class="math inline">\(61\)</span>即可（用来保存可行状态），之后逐行进行状态转移即可。</p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;unordered_map&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">102</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, sta[<span class="number">65</span>], sum[<span class="number">65</span>], cnt, dp[<span class="number">1</span> &lt;&lt; M][<span class="number">65</span>][<span class="number">65</span>], pk[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">char</span> s[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//相邻两个炮兵距离不超过3的这种状态的处理，最多只有60个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(i &amp; (i &lt;&lt; <span class="number">1</span>)) &amp;&amp; !(i &amp; (i &lt;&lt; <span class="number">2</span>))) &#123;</span><br><span class="line">            sta[++cnt] = i;</span><br><span class="line">            <span class="keyword">int</span> j = i, cot = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (j) &#123;</span><br><span class="line">                j -= j &amp; -j;</span><br><span class="line">                cot++;</span><br><span class="line">            &#125;</span><br><span class="line">            sum[cnt] = cot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("test.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("test.out", "w", stdout);</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] == <span class="string">'H'</span>)</span><br><span class="line">                pk[i] += (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(sta[i] &amp; pk[<span class="number">1</span>])) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++)</span><br><span class="line">                dp[<span class="number">1</span>][i][j] = sum[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pk[i] &amp; sta[j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= cnt; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sta[k] &amp; sta[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (sta[k] &amp; pk[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span>; p &lt;= cnt; p++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sta[p] &amp; sta[k]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (sta[p] &amp; sta[j]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (pk[i - <span class="number">2</span>] &amp; sta[p]) <span class="keyword">continue</span>;</span><br><span class="line">                    dp[i][j][k] = max(dp[i][j][k], dp[i - <span class="number">1</span>][k][p] + sum[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++)</span><br><span class="line">            ans = max(ans, dp[n][i][j]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;链接&quot;&gt;链接&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=1185&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\(\text{POJ - 1185 炮兵阵地}\)&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题意&quot;&gt;题意&lt;/h3&gt;
&lt;p&gt;  给你一个&lt;span class=&quot;math inline&quot;&gt;\(N\times M\)&lt;/span&gt;的网格地图，这个地图上的每一格上如果是&lt;code&gt;H&lt;/code&gt;则代表山地，若是&lt;code&gt;P&lt;/code&gt;则代表平原，在平原上可以布置一只炮兵部队（山地上不能部署部队），一只炮兵的攻击范围如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/POJ1185_1.jpg&quot; width=&quot;300px&quot;&gt;&lt;/p&gt;
&lt;p&gt;  现在需要你在这张&lt;span class=&quot;math inline&quot;&gt;\(N\times M\)&lt;/span&gt;的地图上部署部队，在避免误伤的前提下（即任意一支部队都不在其他部队的攻击范围之内），问你最多能布置多少只部队。&lt;/p&gt;
&lt;p&gt;  输入格式：第一行输入&lt;span class=&quot;math inline&quot;&gt;\(N,M\)&lt;/span&gt;，之后输入一个&lt;span class=&quot;math inline&quot;&gt;\(N\times M\)&lt;/span&gt;的使用&lt;code&gt;H&lt;/code&gt;和&lt;code&gt;P&lt;/code&gt;表示的地图。&lt;/p&gt;
&lt;p&gt;  输出格式：输出最多可以布置的部队的数量。&lt;/p&gt;
&lt;p&gt;  数据范围：&lt;span class=&quot;math inline&quot;&gt;\(N\leq 100,M\leq 10\)&lt;/span&gt;
    
    </summary>
    
      <category term="算法" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="dp" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/dp/"/>
    
      <category term="状压dp" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/dp/%E7%8A%B6%E5%8E%8Bdp/"/>
    
    
      <category term="算法" scheme="https://yuggu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="状压dp" scheme="https://yuggu.github.io/tags/%E7%8A%B6%E5%8E%8Bdp/"/>
    
  </entry>
  
  <entry>
    <title>[HDU - 1575] Tr A</title>
    <link href="https://yuggu.github.io/2019/09/25/HDU-1575-Tr-A/"/>
    <id>https://yuggu.github.io/2019/09/25/HDU-1575-Tr-A/</id>
    <published>2019-09-25T11:15:50.000Z</published>
    <updated>2019-09-25T12:52:30.249Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链接">链接</h3><p><a href="https://vjudge.net/problem/SPOJ-NGCD" target="_blank" rel="noopener"><span class="math inline">\(\text{SPOJ - NO GCD}\)</span></a></p><h3 id="题意">题意</h3><p>  A是一个方阵，<span class="math inline">\(Tr\space A\)</span>表示<span class="math inline">\(A\)</span>的迹(即是主对角线上的和)，现在要求<span class="math inline">\(Tr(A^k)\%9973\)</span></p><p>  输入格式：第一行为<span class="math inline">\(t\)</span>，共<span class="math inline">\(t\)</span>组测试样例，每组数据的一行两个数字<span class="math inline">\(n,k\)</span>，接下来<span class="math inline">\(n\)</span>行<span class="math inline">\(n\)</span>列，表示方阵<span class="math inline">\(A\)</span></p><p>  输出格式：每组测试样例一行输出，输出<span class="math inline">\(Tr(A^k)\%9973\)</span></p><p>  数据范围：<span class="math inline">\(2\leq n\leq 10,2\leq k\leq 10^9\)</span> <a id="more"></a></p><h3 id="分析">分析</h3><p>  这是一个矩阵快速幂的模板题；</p><p>  对于<span class="math inline">\(\text{Successione di Fibonacci}\)</span>，有：</p><ul><li><span class="math inline">\(f_{0}=0\)</span></li><li><span class="math inline">\(f_{1}=1\)</span></li><li><span class="math inline">\(f_{n}=f_{n-1}+f_{n-2}（n≧2）\)</span></li></ul><p>  如果需要我们求出<span class="math inline">\(f_{1e9}\%(1e9+7)\)</span>的结果，那么我们直接利用递推公式进行求解，显然是不可行的。</p><p>  定义<span class="math inline">\(F(n)=\begin{bmatrix} f_{n} &amp; f_{n+1} \end{bmatrix}\)</span>，且<span class="math inline">\(f_0=0,f_1=1,f_{n}=f_{n-1}+f_{n-2}（n≧2）\)</span>，我们有：</p><p><span class="math display">\[  F(n)=\begin{bmatrix} f_{n} &amp; f_{n+1}\end{bmatrix} = \begin{bmatrix} f_{n-1} &amp; f_{n}\end{bmatrix}* \begin{bmatrix}0&amp;1\\ 1 &amp; 1\end{bmatrix}=\vdots=\begin{bmatrix} f_{0} &amp; f_{1}\end{bmatrix}*\begin{bmatrix}0&amp;1\\ 1 &amp; 1\end{bmatrix}^{n}\]</span></p><p>  令<span class="math inline">\(A=\begin{bmatrix}0&amp;1\\ 1 &amp; 1\end{bmatrix}\)</span>，则有<span class="math inline">\(F(n)=F(0)*A^{n}\)</span>，实际上我们只要考虑求解<span class="math inline">\(A^n\)</span>即可，如果这里的<span class="math inline">\(A\)</span>是一个整数，那么我们直接快速幂即可，但是这里是一个矩阵。</p><p>  这里有涉及到广义快速幂的概念；</p><p>  <span class="math inline">\((G,*)\)</span>是一个群（<span class="math inline">\(1.*\)</span>在<span class="math inline">\(G\)</span>上的运算是封闭的；<span class="math inline">\(2.\)</span>满足交换律；<span class="math inline">\(3.\)</span>对<span class="math inline">\(G\)</span>中的任意元素含有唯一的单位元；<span class="math inline">\(4.\)</span>除零元外均有逆元），<span class="math inline">\(*\)</span>是一种二元运算（<strong>泛指</strong>），<span class="math inline">\(e\)</span>为<span class="math inline">\(*\)</span>在<span class="math inline">\(G\)</span>上的单位元，<span class="math inline">\(a\in G\)</span>，<span class="math inline">\(e*a=a*e=a\)</span>，<span class="math inline">\((a^{-1})^{-1}=a\)</span>，规定<span class="math inline">\(a^{0}=1,a^{-n}=(a^{n})^{-1}\)</span>，可以证明<span class="math inline">\(a^{m}\cdot a^{n}=a^{m+n}\)</span>，<span class="math inline">\((a^{m})^{n}=a^{mn}\)</span>，那么关于它的快速幂可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typename</span> <span class="title">pow</span><span class="params">(<span class="keyword">typename</span> a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">//ans初始化为单位元</span></span><br><span class="line"><span class="keyword">typename</span> ans = e;</span><br><span class="line"><span class="keyword">while</span> (n) &#123;</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span>) ans = ans * a;</span><br><span class="line">a = a * a;</span><br><span class="line">n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  对于上面的<span class="math inline">\(A^n\)</span>，那么<span class="math inline">\((G,*)\)</span>是一个群，<span class="math inline">\(*\)</span>为矩阵乘法，<span class="math inline">\(G\)</span>元素为<span class="math inline">\(e、A、A^{2}、A^{3}\dots A^{\infty}\)</span>，并且<span class="math inline">\(A\)</span>是一个方阵，那么广义快速幂对于它来说也是成立的，注意<span class="math inline">\(A\)</span>的单位元是单位矩阵。</p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 9973</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fastIO &#123;</span><br><span class="line">    <span class="comment">//#define getchar() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;22, stdin),</span></span><br><span class="line">    <span class="comment">// p1 == p2) ? EOF : *p1++) char buf[(1 &lt;&lt; 22)], *p1 = buf, *p2 = buf;</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c = getchar();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'-'</span>)</span><br><span class="line">                f = <span class="number">-1</span>;</span><br><span class="line">            c = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)</span><br><span class="line">            x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">        <span class="keyword">return</span> x * f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">// namespace fastIO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> fastIO;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    ll M[maxn][maxn];</span><br><span class="line">    Matrix(<span class="keyword">const</span> <span class="keyword">int</span> I = <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(M, <span class="number">0</span>, <span class="keyword">sizeof</span>(M));</span><br><span class="line">        <span class="keyword">if</span> (I)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                M[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp; a) &#123;</span><br><span class="line">        Matrix t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">                    t.M[i][j] = (t.M[i][j] + M[i][k] * a.M[k][j]) % MOD;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">pow</span><span class="params">(Matrix a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">c</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) c = c * a;</span><br><span class="line">        a = a * a;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("test.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("test.out", "w", stdout);</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        Matrix a;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; a.M[i][j];</span><br><span class="line">        Matrix ans = <span class="built_in">pow</span>(a, k);</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            res = (res + ans.M[i][i]) % MOD;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;链接&quot;&gt;链接&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://vjudge.net/problem/SPOJ-NGCD&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\(\text{SPOJ - NO GCD}\)&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题意&quot;&gt;题意&lt;/h3&gt;
&lt;p&gt;  A是一个方阵，&lt;span class=&quot;math inline&quot;&gt;\(Tr\space A\)&lt;/span&gt;表示&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;的迹(即是主对角线上的和)，现在要求&lt;span class=&quot;math inline&quot;&gt;\(Tr(A^k)\%9973\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  输入格式：第一行为&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;，共&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;组测试样例，每组数据的一行两个数字&lt;span class=&quot;math inline&quot;&gt;\(n,k\)&lt;/span&gt;，接下来&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;行&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;列，表示方阵&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  输出格式：每组测试样例一行输出，输出&lt;span class=&quot;math inline&quot;&gt;\(Tr(A^k)\%9973\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  数据范围：&lt;span class=&quot;math inline&quot;&gt;\(2\leq n\leq 10,2\leq k\leq 10^9\)&lt;/span&gt;
    
    </summary>
    
      <category term="算法" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="数学" scheme="https://yuggu.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="广义快速幂" scheme="https://yuggu.github.io/tags/%E5%B9%BF%E4%B9%89%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
      <category term="矩阵快速幂" scheme="https://yuggu.github.io/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>[SPOJ NO GCD]</title>
    <link href="https://yuggu.github.io/2019/09/25/SPOJ-NO-GCD/"/>
    <id>https://yuggu.github.io/2019/09/25/SPOJ-NO-GCD/</id>
    <published>2019-09-25T09:24:45.000Z</published>
    <updated>2019-09-27T12:18:10.636Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链接">链接</h3><p><a href="https://vjudge.net/problem/SPOJ-NGCD" target="_blank" rel="noopener"><span class="math inline">\(\text{SPOJ - NO GCD}\)</span></a></p><h3 id="题意">题意</h3><p>  给你一个长度为<span class="math inline">\(n\)</span>的序列<span class="math inline">\(a\)</span>，并且对于任意一个数<span class="math inline">\(a[i]\)</span>，它只有小于<span class="math inline">\(50\)</span>的素因子，且不含有平方因子，求有多少对<span class="math inline">\((i,j)\)</span>，使得<span class="math inline">\(a[i]和a[j]\)</span>互质，或者<span class="math inline">\(gcd\)</span>是质数。</p><p>  输入格式：第一行输入<span class="math inline">\(t\)</span>，包含<span class="math inline">\(t\)</span>组样例，下面每组样例第一行一个<span class="math inline">\(n\)</span>，下面一行输入一个长度为<span class="math inline">\(n\)</span>的序列<span class="math inline">\(a\)</span>。</p><p>  数据范围：<span class="math inline">\(1\leq t\leq 10,1\leq 100000\)</span>.</p><p>  输出格式：每个样例对应一行一个输出结果。 <a id="more"></a></p><h3 id="分析">分析</h3><p>  这一题是偶然在别人博客看到的，几乎没怎么写过数学题，感到这个思路非常非常的巧妙。</p><p>  首先考虑到了<span class="math inline">\(50\)</span>以内的素数仅有<span class="math inline">\(15\)</span>个，而对于<span class="math inline">\(a\)</span>序列中的任意两个数来说，它们的<span class="math inline">\(gcd\)</span>要么为<span class="math inline">\(1\)</span>，要么在这<span class="math inline">\(15\)</span>个素数之中，要么为<span class="math inline">\(1\)</span>，如果用二进制表示，那么则有它们二进制表示的与的结果为<span class="math inline">\(0\)</span>，或者某一位为<span class="math inline">\(1\)</span>(恰好有一个素因子)。对于一个二进制表示<span class="math inline">\(i\)</span>来说，我们需要求出它的个数与，它补集的子集个数的乘积，这即是求出了<span class="math inline">\(gcd\)</span>为<span class="math inline">\(1\)</span>的情况，对于不为<span class="math inline">\(1\)</span>的情况，我们求出它与，它的补集对某一位<span class="math inline">\(0\)</span>取反变成<span class="math inline">\(1\)</span>的所有子集个数在减去它补集没去反之间子集的个数，这二者乘积，对所有的状态进行累加。</p><p>  关键是如何快速求子集个数，对于<span class="math inline">\(i\)</span>，求所有的<span class="math inline">\(j\)</span>，<span class="math inline">\(j\leq i \&amp;\&amp;(i|j)==i\)</span>。网上代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=i;;j=(j<span class="number">-1</span>)&amp;i)&#123;   </span><br><span class="line"><span class="comment">//s[i]为i的子集的个数，子集j对应的个数为num[j]     </span></span><br><span class="line">        s[i]+=num[j]; <span class="comment">//关键，得到子集 </span></span><br><span class="line">        <span class="keyword">if</span>(!j) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fastIO &#123;</span><br><span class="line">    <span class="comment">//#define getchar() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;22, stdin),</span></span><br><span class="line">    <span class="comment">// p1 == p2) ? EOF : *p1++) char buf[(1 &lt;&lt; 22)], *p1 = buf, *p2 = buf;</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c = getchar();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'-'</span>)</span><br><span class="line">                f = <span class="number">-1</span>;</span><br><span class="line">            c = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)</span><br><span class="line">            x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">        <span class="keyword">return</span> x * f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">// namespace fastIO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> fastIO;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1</span> &lt;&lt; <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, a[M], b[M], p[<span class="number">16</span>] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>&#125;;</span><br><span class="line">                                <span class="comment">//2,3,5,7,11,13,17,19,23,29,31,37,41,43,47</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        ll x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">15</span>; j++)</span><br><span class="line">                <span class="keyword">if</span> (x % p[j] == <span class="number">0</span>) temp += (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">            <span class="comment">//x为1时，temp为0</span></span><br><span class="line">            a[temp]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">            <span class="comment">//枚举j二进制表示下的子集</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;;j = (j - <span class="number">1</span>)&amp; i) &#123;</span><br><span class="line">                b[i] += a[j];</span><br><span class="line">                <span class="comment">//写在这里，是考虑特殊情况，比如输入的x为1</span></span><br><span class="line">                <span class="keyword">if</span> (!j) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            <span class="comment">//gcd为1</span></span><br><span class="line">            ans += <span class="number">1l</span>l * a[i] * b[i ^ (M - <span class="number">1</span>)];</span><br><span class="line">            <span class="comment">//gcd为一个素数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">15</span>; j++)</span><br><span class="line">                <span class="keyword">if</span> ((i &gt;&gt; j) &amp; <span class="number">1</span>)</span><br><span class="line">                    ans += <span class="number">1l</span>l * a[i] * (b[i ^ (M - <span class="number">1</span>) ^ (<span class="number">1</span> &lt;&lt; j)] - b[i ^ (M - <span class="number">1</span>)]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;链接&quot;&gt;链接&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://vjudge.net/problem/SPOJ-NGCD&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\(\text{SPOJ - NO GCD}\)&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题意&quot;&gt;题意&lt;/h3&gt;
&lt;p&gt;  给你一个长度为&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;的序列&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;，并且对于任意一个数&lt;span class=&quot;math inline&quot;&gt;\(a[i]\)&lt;/span&gt;，它只有小于&lt;span class=&quot;math inline&quot;&gt;\(50\)&lt;/span&gt;的素因子，且不含有平方因子，求有多少对&lt;span class=&quot;math inline&quot;&gt;\((i,j)\)&lt;/span&gt;，使得&lt;span class=&quot;math inline&quot;&gt;\(a[i]和a[j]\)&lt;/span&gt;互质，或者&lt;span class=&quot;math inline&quot;&gt;\(gcd\)&lt;/span&gt;是质数。&lt;/p&gt;
&lt;p&gt;  输入格式：第一行输入&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;，包含&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;组样例，下面每组样例第一行一个&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;，下面一行输入一个长度为&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;的序列&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;  数据范围：&lt;span class=&quot;math inline&quot;&gt;\(1\leq t\leq 10,1\leq 100000\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;  输出格式：每个样例对应一行一个输出结果。
    
    </summary>
    
      <category term="算法" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="思维" scheme="https://yuggu.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="数学" scheme="https://yuggu.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>[HC - 1044] 状态压缩一</title>
    <link href="https://yuggu.github.io/2019/09/22/HC-1044-%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E4%B8%80/"/>
    <id>https://yuggu.github.io/2019/09/22/HC-1044-状态压缩一/</id>
    <published>2019-09-22T07:01:35.000Z</published>
    <updated>2019-09-29T10:59:44.185Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链接">链接</h3><p><a href="https://hihocoder.com/problemset/problem/1044" target="_blank" rel="noopener"><span class="math inline">\(\text{hihoCoder - 1044 状态压缩一}\)</span></a></p><h3 id="题意">题意</h3><p>  火车上有<span class="math inline">\(n\)</span>个座位排成一排，第<span class="math inline">\(i\)</span>个座位上有数目<span class="math inline">\(w[i]\)</span>的垃圾，你需要尽可能多的清扫这些垃圾，然而在连续<span class="math inline">\(m\)</span>个座位上，你最多只能选取<span class="math inline">\(q\)</span>个位置进行清扫，不然会让乘客不愉快，现在问你最多可以清扫多少数目的垃圾；</p><p>  输入格式：输入包含一组样例，第一行三个数<span class="math inline">\(n,m,q\)</span>，第二行<span class="math inline">\(n\)</span>个整数，第<span class="math inline">\(i\)</span>个为<span class="math inline">\(w[i]\)</span>;</p><p>  数据范围：<span class="math inline">\(N\leq 1000,2\leq M\leq 10,1\leq q\leq m,w[i]\leq 100\)</span>.</p><p>  输出格式：输出一行代表最多可以清扫的垃圾数目； <a id="more"></a></p><h3 id="分析">分析</h3><p>  如果我们考虑每个位置的选与不选，那么最多可能有<span class="math inline">\(2^1000\)</span>种状态，显然这种想法不现实，我们发现，如果当前位置<span class="math inline">\(i\)</span>的前<span class="math inline">\(m-1\)</span>个位置中已经选了<span class="math inline">\(q\)</span>个了(即在<span class="math inline">\([i-m+1,i-1]\)</span>中选<span class="math inline">\(q\)</span>个)，这种状态为<span class="math inline">\(j\)</span>，那么显然当前位置一定不能选，所以当前位置的最大值等于，在第<span class="math inline">\(i-1\)</span>个位置，<span class="math inline">\([i-m+1,i-1]\)</span>中选了<span class="math inline">\(q\)</span>个，而第<span class="math inline">\(i-m\)</span>这个位置一定不选(对于<span class="math inline">\(i-1\)</span>来说，需要在<span class="math inline">\([i-m,i-1]\)</span>中选<span class="math inline">\(q\)</span>个)，这时候的最大值，同理当第<span class="math inline">\(i\)</span>个位置选的时候，考虑它的状态可以从<span class="math inline">\(i-1\)</span>的什么状态转移过来即可。</p><p>  第<span class="math inline">\(i\)</span>个座位为阶段，<span class="math inline">\(i\)</span>之前包括<span class="math inline">\(i\)</span>个<span class="math inline">\(m\)</span>个选若干个为状态。</p><p>  首先预处理一下，<span class="math inline">\(m\)</span>个连续座位里选小于<span class="math inline">\(q\)</span>个座位的状态，具体细节见代码。</p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 2</span></span><br><span class="line"><span class="comment">//#define MOD 99991</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD(a, b) a &gt;= b ? a % b + b : a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fastIO &#123;</span><br><span class="line">    <span class="comment">//#define getchar() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;22, stdin),</span></span><br><span class="line">    <span class="comment">// p1 == p2) ? EOF : *p1++) char buf[(1 &lt;&lt; 22)], *p1 = buf, *p2 = buf;</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c = getchar();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'-'</span>)</span><br><span class="line">                f = <span class="number">-1</span>;</span><br><span class="line">            c = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)</span><br><span class="line">            x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">        <span class="keyword">return</span> x * f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">// namespace fastIO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> fastIO;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q, w[<span class="number">1005</span>], f[<span class="number">1005</span>][<span class="number">1</span> &lt;&lt; <span class="number">12</span>], mark[<span class="number">1</span> &lt;&lt; <span class="number">12</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("test.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("test.out", "w", stdout);</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>) cnt++;</span><br><span class="line">        mark[i] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; m; j++) &#123; </span><br><span class="line">            <span class="keyword">if</span> (mark[j] &lt;= q) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &amp; <span class="number">1</span>)  f[i][j] = max(f[i - <span class="number">1</span>][j &gt;&gt; <span class="number">1</span>], f[i - <span class="number">1</span>][(j &gt;&gt; <span class="number">1</span>) + (<span class="number">1</span> &lt;&lt; (m - <span class="number">1</span>))]) + w[i];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mark[j] == q) f[i][j] = f[i - <span class="number">1</span>][j &gt;&gt; <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (mark[j] &lt; q)</span><br><span class="line">                        f[i][j] = max(f[i - <span class="number">1</span>][j &gt;&gt; <span class="number">1</span>], f[i - <span class="number">1</span>][(j &gt;&gt; <span class="number">1</span>) + (<span class="number">1</span> &lt;&lt; (m - <span class="number">1</span>))]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i++)</span><br><span class="line">        <span class="keyword">if</span> (mark[i] &lt;= q) ans = max(f[n][i], ans);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;链接&quot;&gt;链接&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://hihocoder.com/problemset/problem/1044&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\(\text{hihoCoder - 1044 状态压缩一}\)&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题意&quot;&gt;题意&lt;/h3&gt;
&lt;p&gt;  火车上有&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个座位排成一排，第&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;个座位上有数目&lt;span class=&quot;math inline&quot;&gt;\(w[i]\)&lt;/span&gt;的垃圾，你需要尽可能多的清扫这些垃圾，然而在连续&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;个座位上，你最多只能选取&lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt;个位置进行清扫，不然会让乘客不愉快，现在问你最多可以清扫多少数目的垃圾；&lt;/p&gt;
&lt;p&gt;  输入格式：输入包含一组样例，第一行三个数&lt;span class=&quot;math inline&quot;&gt;\(n,m,q\)&lt;/span&gt;，第二行&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个整数，第&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;个为&lt;span class=&quot;math inline&quot;&gt;\(w[i]\)&lt;/span&gt;;&lt;/p&gt;
&lt;p&gt;  数据范围：&lt;span class=&quot;math inline&quot;&gt;\(N\leq 1000,2\leq M\leq 10,1\leq q\leq m,w[i]\leq 100\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;  输出格式：输出一行代表最多可以清扫的垃圾数目；
    
    </summary>
    
      <category term="算法" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="dp" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/dp/"/>
    
      <category term="状压dp" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/dp/%E7%8A%B6%E5%8E%8Bdp/"/>
    
    
      <category term="算法" scheme="https://yuggu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="状压dp" scheme="https://yuggu.github.io/tags/%E7%8A%B6%E5%8E%8Bdp/"/>
    
  </entry>
  
  <entry>
    <title>[POJ - 2411] Mondriaan&#39;s Dream</title>
    <link href="https://yuggu.github.io/2019/09/22/POJ-2411-Mondriaan-s-Dream/"/>
    <id>https://yuggu.github.io/2019/09/22/POJ-2411-Mondriaan-s-Dream/</id>
    <published>2019-09-22T06:17:51.000Z</published>
    <updated>2019-09-29T10:52:01.554Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链接">链接</h3><p><a href="http://poj.org/problem?id=2411" target="_blank" rel="noopener"><span class="math inline">\(\text{POJ - 2411 Mondriaan&#39;s Dream}\)</span></a></p><h3 id="题意">题意</h3><p>  求把<span class="math inline">\(N\ast M\)</span>的棋盘分割成若干个<span class="math inline">\(1\ast 2\)</span>的长方形，有多少种方案。如<span class="math inline">\(N=2，M=4\)</span>，有<span class="math inline">\(5\)</span>种方案，<span class="math inline">\(N=2，M=3\)</span>有<span class="math inline">\(3\)</span>种方案： <img src="/images/poj2411_2.png" width="500px"></p><p>  输入格式：输入包含多组样例，每行一个样例，每个样例一行两个数<span class="math inline">\(N,M\)</span>.</p><p>  数据范围：<span class="math inline">\(1\leq N,M\leq 11\)</span>.</p><p>  输出格式：每个样例输出一行代表方案数。 <a id="more"></a></p><h3 id="分析">分析</h3><p>  总共<span class="math inline">\(N\)</span>行<span class="math inline">\(M\)</span>列，考虑将每一列的长方形的摆放当作状态，第<span class="math inline">\(i\)</span>行即是第<span class="math inline">\(i\)</span>阶段；</p><p>  将长方形的状态定义为如下：</p><p><img src="/images/poj2411_1.png" width="400px"></p><p>  使用一个<span class="math inline">\(M\)</span>位二进制数，若第<span class="math inline">\(j(0\leq j&lt;M)\)</span>位为<span class="math inline">\(1\)</span>，则表示这个位置是一个竖着的长方形的上半部，为0则是其他情况，<span class="math inline">\(f[i][j]\)</span>表示第<span class="math inline">\(i\)</span>行的状态为<span class="math inline">\(j\)</span>时，前<span class="math inline">\(i\)</span>行分割方案的总数，当第<span class="math inline">\(i\)</span>的状态<span class="math inline">\(j\)</span>能向第<span class="math inline">\(i+1\)</span>行状态<span class="math inline">\(k\)</span>转移时，必有<span class="math inline">\((j\&amp;k)==0\)</span>，且<span class="math inline">\(j|k\)</span>的结果中每一段连续的<span class="math inline">\(0\)</span>都必须有偶数个</p><p>   我们可以从<span class="math inline">\([0,(1&lt;&lt;M)-1]\)</span>中预处理出并记录，二进制表示下连续的<span class="math inline">\(0\)</span>有偶数个的所有状态，记录在<span class="math inline">\(S\)</span>集合中。</p><p><span class="math display">\[f[i][j]=\sum_{j\&amp;k=0\space and\space j|k\in S} f[i-1][k]\]</span></p><p>  初始值<span class="math inline">\(f[0][0]=1\)</span>，其余为0，目标为<span class="math inline">\(f[N][0]\)</span>，复杂度为<span class="math inline">\(O(4^MN)\)</span>.</p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 2</span></span><br><span class="line"><span class="comment">//#define MOD 99991</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD(a, b) a &gt;= b ? a % b + b : a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fastIO &#123;</span><br><span class="line">    <span class="comment">//#define getchar() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;22, stdin),</span></span><br><span class="line">    <span class="comment">// p1 == p2) ? EOF : *p1++) char buf[(1 &lt;&lt; 22)], *p1 = buf, *p2 = buf;</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c = getchar();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'-'</span>)</span><br><span class="line">                f = <span class="number">-1</span>;</span><br><span class="line">            c = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)</span><br><span class="line">            x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">        <span class="keyword">return</span> x * f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">// namespace fastIO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> fastIO;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h, w;</span><br><span class="line">ll f[<span class="number">12</span>][<span class="number">1</span> &lt;&lt; <span class="number">12</span>], sta[<span class="number">1</span> &lt;&lt; <span class="number">12</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("test.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("test.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;h, &amp;w) != EOF) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!h || !w) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="built_in">memset</span>(sta, <span class="number">0</span>, <span class="keyword">sizeof</span>(sta));</span><br><span class="line">        <span class="comment">//预处理二进制表示下每一段连续的0都有偶数个的状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; w; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> odd = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w; j++)</span><br><span class="line">                <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>) odd |= cnt, cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> cnt ^= <span class="number">1</span>;</span><br><span class="line">            sta[i] = odd | cnt ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= h; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; w; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1</span> &lt;&lt; w; k++)</span><br><span class="line">                    <span class="keyword">if</span> (sta[j | k] &amp;&amp; (j &amp; k) == <span class="number">0</span>)</span><br><span class="line">                        f[i][k] += f[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; f[h][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;链接&quot;&gt;链接&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=2411&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\(\text{POJ - 2411 Mondriaan&amp;#39;s Dream}\)&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题意&quot;&gt;题意&lt;/h3&gt;
&lt;p&gt;  求把&lt;span class=&quot;math inline&quot;&gt;\(N\ast M\)&lt;/span&gt;的棋盘分割成若干个&lt;span class=&quot;math inline&quot;&gt;\(1\ast 2\)&lt;/span&gt;的长方形，有多少种方案。如&lt;span class=&quot;math inline&quot;&gt;\(N=2，M=4\)&lt;/span&gt;，有&lt;span class=&quot;math inline&quot;&gt;\(5\)&lt;/span&gt;种方案，&lt;span class=&quot;math inline&quot;&gt;\(N=2，M=3\)&lt;/span&gt;有&lt;span class=&quot;math inline&quot;&gt;\(3\)&lt;/span&gt;种方案： &lt;img src=&quot;/images/poj2411_2.png&quot; width=&quot;500px&quot;&gt;&lt;/p&gt;
&lt;p&gt;  输入格式：输入包含多组样例，每行一个样例，每个样例一行两个数&lt;span class=&quot;math inline&quot;&gt;\(N,M\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;  数据范围：&lt;span class=&quot;math inline&quot;&gt;\(1\leq N,M\leq 11\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;  输出格式：每个样例输出一行代表方案数。
    
    </summary>
    
      <category term="算法" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="dp" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/dp/"/>
    
      <category term="状压dp" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/dp/%E7%8A%B6%E5%8E%8Bdp/"/>
    
    
      <category term="算法" scheme="https://yuggu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="状压dp" scheme="https://yuggu.github.io/tags/%E7%8A%B6%E5%8E%8Bdp/"/>
    
  </entry>
  
  <entry>
    <title>[Shortest Hamilton path]</title>
    <link href="https://yuggu.github.io/2019/09/22/Shortest-Hamilton-path/"/>
    <id>https://yuggu.github.io/2019/09/22/Shortest-Hamilton-path/</id>
    <published>2019-09-22T05:25:38.000Z</published>
    <updated>2019-09-29T11:01:14.013Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链接">链接</h3><p><a href="https://www.acwing.com/problem/content/93/" target="_blank" rel="noopener"><span class="math inline">\(\text{最短Hamilton路径}\)</span></a></p><h3 id="题意">题意</h3><p>  给定一张<span class="math inline">\(n\)</span>个点的带权无向图，点从<span class="math inline">\(0\)</span>到<span class="math inline">\(n-1\)</span>标号，求起点<span class="math inline">\(0\)</span>到终点<span class="math inline">\(n-1\)</span>的最短<span class="math inline">\(\text{Hamilton}\)</span>路径。 <span class="math inline">\(\text{Hamilton}\)</span>路径的定义是从<span class="math inline">\(0\)</span>到<span class="math inline">\(n-1\)</span>不重不漏地经过每个点恰好一次。</p><p>  输入格式：第一行一个整数<span class="math inline">\(n\)</span>，接下来一个<span class="math inline">\(n\times n\)</span>的矩阵<span class="math inline">\(a[i,j]\)</span>，代表图中点与点之间的关系;</p><p>  数据范围：<span class="math inline">\(1\leq n\leq 20,0\leq a[i,j]\leq 10^7\)</span>.</p><p>  输出格式：输出一个整数，表示最短<span class="math inline">\(\text{Hamilton}\)</span>路径的长度。 <a id="more"></a></p><h3 id="分析">分析</h3><p>  首先很容易想到一种方法，枚举<span class="math inline">\(n\)</span>个点的排列，然后计算最小值，那么复杂度是<span class="math inline">\(O(n\ast n!)\)</span>，然而<span class="math inline">\(20!\)</span>大约是<span class="math inline">\(2e18\)</span>，显然不可行；之后不知什么人想出来一种比较巧妙的方法。</p><p>  考虑使用二进制表示状态，从一个点转移到另一个点，两个点之间的状态转移的差距，体现在二进制上仅仅是一位不同；</p><p>  使用一个<span class="math inline">\(n\)</span>位二进制数，若第<span class="math inline">\(i(0\leq i&lt; n)\)</span>位为<span class="math inline">\(1\)</span>，则表示第<span class="math inline">\(i\)</span>个点已经被访问过了，反之未被访问过，在任意时刻还需要知道当前所在的位置，所以使用<span class="math inline">\(f[i,j](0\leq i&lt;2^n,0\leq j&lt;n)\)</span>表示点被经过的状态对应的二进制数为<span class="math inline">\(i\)</span>，且目前处于点<span class="math inline">\(j\)</span>时的最短路径。</p><p>  在起点<span class="math inline">\(0\)</span>时，有<span class="math inline">\(f[1][0]=0\)</span>(<span class="math inline">\(0\)</span>点的状态是<span class="math inline">\(1\)</span>)，其他设为<span class="math inline">\(\infty\)</span>，目标是<span class="math inline">\(f[(1&lt;&lt; n)-1][n-1]\)</span>，即经过所有点(<span class="math inline">\(i\)</span>的所有位都为<span class="math inline">\(1\)</span>)，并且最终位于<span class="math inline">\(n-1\)</span>位置，动态转移方程为： <span class="math display">\[f[i][j]=\min{f[i\space xor(1 &lt;&lt; j)][k]+weight[k][j]}\]</span>   枚举当前的位置和当前位置的前一个位置，复杂度为<span class="math inline">\(O(n^2 \ast 2^n)\)</span>.</p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 2</span></span><br><span class="line"><span class="comment">//#define MOD 99991</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD(a, b) a &gt;= b ? a % b + b : a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fastIO &#123;</span><br><span class="line">    <span class="comment">//#define getchar() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;22, stdin),</span></span><br><span class="line">    <span class="comment">// p1 == p2) ? EOF : *p1++) char buf[(1 &lt;&lt; 22)], *p1 = buf, *p2 = buf;</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c = getchar();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'-'</span>)</span><br><span class="line">                f = <span class="number">-1</span>;</span><br><span class="line">            c = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)</span><br><span class="line">            x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">        <span class="keyword">return</span> x * f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">// namespace fastIO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> fastIO;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, f[(<span class="number">1</span> &lt;&lt; <span class="number">21</span>) - <span class="number">1</span>][<span class="number">25</span>], e[<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("test.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("test.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, INF, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                e[i][j] = read();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) </span><br><span class="line">                        <span class="keyword">if</span> (i &gt;&gt; k &amp; <span class="number">1</span>)</span><br><span class="line">                            f[i][j] = min(f[i][j], f[i ^ <span class="number">1</span> &lt;&lt; j][k] + e[j][k]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;链接&quot;&gt;链接&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.acwing.com/problem/content/93/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\(\text{最短Hamilton路径}\)&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题意&quot;&gt;题意&lt;/h3&gt;
&lt;p&gt;  给定一张&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个点的带权无向图，点从&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;到&lt;span class=&quot;math inline&quot;&gt;\(n-1\)&lt;/span&gt;标号，求起点&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;到终点&lt;span class=&quot;math inline&quot;&gt;\(n-1\)&lt;/span&gt;的最短&lt;span class=&quot;math inline&quot;&gt;\(\text{Hamilton}\)&lt;/span&gt;路径。 &lt;span class=&quot;math inline&quot;&gt;\(\text{Hamilton}\)&lt;/span&gt;路径的定义是从&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;到&lt;span class=&quot;math inline&quot;&gt;\(n-1\)&lt;/span&gt;不重不漏地经过每个点恰好一次。&lt;/p&gt;
&lt;p&gt;  输入格式：第一行一个整数&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;，接下来一个&lt;span class=&quot;math inline&quot;&gt;\(n\times n\)&lt;/span&gt;的矩阵&lt;span class=&quot;math inline&quot;&gt;\(a[i,j]\)&lt;/span&gt;，代表图中点与点之间的关系;&lt;/p&gt;
&lt;p&gt;  数据范围：&lt;span class=&quot;math inline&quot;&gt;\(1\leq n\leq 20,0\leq a[i,j]\leq 10^7\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;  输出格式：输出一个整数，表示最短&lt;span class=&quot;math inline&quot;&gt;\(\text{Hamilton}\)&lt;/span&gt;路径的长度。
    
    </summary>
    
      <category term="算法" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="dp" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/dp/"/>
    
      <category term="状压dp" scheme="https://yuggu.github.io/categories/%E7%AE%97%E6%B3%95/dp/%E7%8A%B6%E5%8E%8Bdp/"/>
    
    
      <category term="算法" scheme="https://yuggu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="状压dp" scheme="https://yuggu.github.io/tags/%E7%8A%B6%E5%8E%8Bdp/"/>
    
  </entry>
  
  <entry>
    <title>Network Fundamentals</title>
    <link href="https://yuggu.github.io/2019/09/21/Network-Fundamentals/"/>
    <id>https://yuggu.github.io/2019/09/21/Network-Fundamentals/</id>
    <published>2019-09-21T10:23:42.000Z</published>
    <updated>2019-11-20T05:46:17.578Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主机与服务器">主机与服务器</h3><p>  <strong>网络主机</strong>（<strong>network host</strong>）是已连接到一个<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C" title="计算机网络" target="_blank" rel="noopener">计算机网络</a>的一台<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E8%A8%88%E7%AE%97%E6%A9%9F" title="电子计算机" target="_blank" rel="noopener">电子计算机</a>或其他设备。网络主机可以向网络上的用户或其他<a href="https://zh.wikipedia.org/wiki/%E8%8A%82%E7%82%B9_(%E7%94%B5%E4%BF%A1%E7%BD%91%E7%BB%9C)" title="节点 (电信网络)" target="_blank" rel="noopener">节点</a>提供信息资源、服务和应用。一台网络主机是已被分配一个<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%B1%82" title="网络层" target="_blank" rel="noopener">网络层</a><a href="https://zh.wikipedia.org/w/index.php?title=%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">主机地址</a>的网络节点。</p><p>  所有服务器都是主机，但并非所有主机都是服务器，任何与网络建立连接的设备都可以作为主机，而已接受其他设备连接为目的的主机被视作服务器。 <a id="more"></a></p><h2 id="分类的ip地址">分类的IP地址</h2><h3 id="ip地址">IP地址</h3><p>  整个互联网就是一个单一的、抽象的网络，IP地址就是给网络上的每一个主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32位的标识符。IP地址的结构是使我们可以在互联网上很方便的寻址（如对于一个IPv4的地址，我们先根据网络号找出此IP所在的网段，再根据主机号找到具体的主机或路由器）。</p><h3 id="ip地址表示方法">IP地址表示方法</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;主机与服务器&quot;&gt;主机与服务器&lt;/h3&gt;
&lt;p&gt;  &lt;strong&gt;网络主机&lt;/strong&gt;（&lt;strong&gt;network host&lt;/strong&gt;）是已连接到一个&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C&quot; title=&quot;计算机网络&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;计算机网络&lt;/a&gt;的一台&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E8%A8%88%E7%AE%97%E6%A9%9F&quot; title=&quot;电子计算机&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;电子计算机&lt;/a&gt;或其他设备。网络主机可以向网络上的用户或其他&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%8A%82%E7%82%B9_(%E7%94%B5%E4%BF%A1%E7%BD%91%E7%BB%9C)&quot; title=&quot;节点 (电信网络)&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;节点&lt;/a&gt;提供信息资源、服务和应用。一台网络主机是已被分配一个&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%B1%82&quot; title=&quot;网络层&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;网络层&lt;/a&gt;&lt;a href=&quot;https://zh.wikipedia.org/w/index.php?title=%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80&amp;amp;action=edit&amp;amp;redlink=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;主机地址&lt;/a&gt;的网络节点。&lt;/p&gt;
&lt;p&gt;  所有服务器都是主机，但并非所有主机都是服务器，任何与网络建立连接的设备都可以作为主机，而已接受其他设备连接为目的的主机被视作服务器。
    
    </summary>
    
      <category term="Networks" scheme="https://yuggu.github.io/categories/Networks/"/>
    
      <category term="Fundmentals" scheme="https://yuggu.github.io/categories/Networks/Fundmentals/"/>
    
    
      <category term="network" scheme="https://yuggu.github.io/tags/network/"/>
    
      <category term="主机" scheme="https://yuggu.github.io/tags/%E4%B8%BB%E6%9C%BA/"/>
    
  </entry>
  
</feed>
